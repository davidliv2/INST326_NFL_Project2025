# -*- coding: utf-8 -*-
"""nfl_system

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZmCpI91_0uWSBmIeyc7vmg8hIUT9p2Z7
"""

"""
Project 2
Team: Gridiron Data Systems (David, Dash, Andrew)
Course: INST326
5 main classes: Player, StatsDataset, AnalyticsEngine, Visualizer, and Exporter.
"""

# ===============================================================
# Imports and Shared Utilities (from Project 1)
# ===============================================================
from typing import Optional, Dict, List
import os
from datetime import datetime, timedelta
import pandas as pd
import matplotlib.pyplot as plt
# ===============================================================

# validation and helpers
VALID_TEAMS = {
    "ARI", "ATL", "BAL", "BUF", "CAR", "CHI", "CIN", "CLE",
    "DAL", "DEN", "DET", "GB", "HOU", "IND", "JAX", "KC",
    "LV", "LAC", "LAR", "MIA", "MIN", "NE", "NO", "NYG",
    "NYJ", "PHI", "PIT", "SEA", "SF", "TB", "TEN", "WAS"
}
VALID_POSITIONS = {"QB", "RB", "WR", "TE", "K", "P", "CB", "S", "LB", "DL", "OL"}


def clean_name(name: str) -> str:
    """make player names look normal"""
    if not isinstance(name, str):
        return ""
    return " ".join(name.strip().split()).title()


def validate_team(team: str) -> bool:
    return isinstance(team, str) and team.upper() in VALID_TEAMS


def validate_position(pos: str) -> bool:
    return isinstance(pos, str) and pos.upper() in VALID_POSITIONS


def safe_divide(a: float, b: float, default: float = 0.0) -> float:
    return a / b if b != 0 else default


# ==============================================
# CLASS 1: Player
# ==============================================
class Player:
    """Player class for our NFL project."""

    def __init__(
        self,
        name: str,
        team: Optional[str] = None,
        position: Optional[str] = None,
        games_df: Optional[pd.DataFrame] = None,
    ):
        fixed_name = clean_name(name)
        if fixed_name == "":
            raise ValueError("Player name cannot be empty.")

        if team and not validate_team(team):
            raise ValueError("Team must be a valid NFL team code.")
        if position and not validate_position(position):
            raise ValueError("Position must be a valid NFL position.")

        self.name = fixed_name
        self.team = team
        self.position = position
        self.games_df = games_df

    def efficiency(self) -> Dict[str, float]:
        """yards/play and td rate from the data we have"""
        if self.games_df is None or "yards" not in self.games_df.columns:
            return {"ypp": 0.0, "td_rate": 0.0}

        yards = float(self.games_df["yards"].sum())
        plays = float(self.games_df["plays"].sum()) if "plays" in self.games_df.columns else len(self.games_df)
        tds = float(self.games_df["td"].sum()) if "td" in self.games_df.columns else 0.0

        ypp = safe_divide(yards, plays)
        td_rate = safe_divide(tds, plays)

        return {"ypp": round(ypp, 3), "td_rate": round(td_rate, 4)}

    def __str__(self):
        pos = self.position if self.position else "N/A"
        team = self.team if self.team else "FA"
        return f"{self.name} ({pos}) - {team}"

    def __repr__(self):
        return f"Player(name='{self.name}', team='{self.team}', position='{self.position}')"


# ===============================================================
# CLASS 2: StatsDataset
# ===============================================================
class StatsDataset:
    """Stores and works with NFL stats in a DataFrame."""

    def __init__(self, df: pd.DataFrame):
        if not isinstance(df, pd.DataFrame):
            raise ValueError("StatsDataset requires a DataFrame.")
        if df.empty:
            print("‚ö†Ô∏è Warning: Initialized StatsDataset with an empty DataFrame.")
        self._df = df

    @property
    def df(self) -> pd.DataFrame:
        """return a copy so it doesn‚Äôt get changed outside"""
        return self._df.copy()

    @classmethod
    def from_csv(cls, path: str) -> "StatsDataset":
        """load stats from a CSV file"""
        try:
            if not os.path.exists(path):
                raise FileNotFoundError(f"CSV file not found: {path}")

            df = pd.read_csv(path)
            if df.empty:
                raise ValueError(f"CSV file is empty: {path}")

            print(f"‚úÖ Loaded {len(df)} rows from {path}")
            return cls(df)

        except pd.errors.EmptyDataError:
            raise ValueError(f"CSV file contains no data: {path}")
        except Exception as e:
            print(f"‚ùå Error loading CSV: {e}")
            raise

    def leaderboard(
        self,
        stat: str,
        position: Optional[str] = None,
        season: Optional[int] = None,
        top_n: int = 10,
    ) -> pd.DataFrame:
        """create top player leaderboard"""
        data = self._df.copy()
        if "player" not in data.columns or stat not in data.columns:
            print(f"‚ö†Ô∏è Need 'player' and '{stat}' columns.")
            return pd.DataFrame()

        if season is not None and "season" in data.columns:
            data = data[data["season"] == season]

        if position is not None and "position" in data.columns:
            data = data[data["position"].str.upper() == position.upper()]

        out = (
            data.groupby("player")[stat]
            .sum(numeric_only=True)
            .reset_index()
            .sort_values(stat, ascending=False)
            .head(top_n)
        )
        out.insert(0, "rank", range(1, len(out) + 1))
        return out[["rank", "player", stat]]

    def compare_players(self, players: List[str], stats: List[str]) -> Dict[str, Dict[str, float]]:
        """compare a few players on selected stats"""
        data = self._df.copy()
        results: Dict[str, Dict[str, float]] = {}

        if "player" not in data.columns:
            print("‚ö†Ô∏è compare_players: missing 'player' column")
            return results

        for p in players:
            p_clean = clean_name(p)
            sub = data[data["player"].astype(str).str.lower() == p_clean.lower()]

            if sub.empty:
                print(f"‚ö†Ô∏è No data found for {p_clean}")

            results[p_clean] = {
                s: float(sub[s].sum()) if s in sub.columns else 0.0
                for s in stats
            }

        return results


# ===============================================================
# CLASS 3: AnalyticsEngine
# ===============================================================
class AnalyticsEngine:
    """Handles NFL calculations and forecasts."""

    @staticmethod
    def qb_rating(att: int, comp: int, yds: int, td: int, ints: int) -> float:
        """calculate NFL passer rating"""
        if att <= 0:
            print("‚ö†Ô∏è qb_rating: attempts must be > 0")
            return 0.0

        def clip(x: float) -> float:
            return max(0.0, min(2.375, x))

        a = clip(((comp / att) - 0.3) * 5)
        b = clip(((yds / att) - 3) * 0.25)
        c = clip((td / att) * 20)
        d = clip(2.375 - ((ints / att) * 25))

        rating = ((a + b + c + d) / 6) * 100
        return round(rating, 1)

    @staticmethod
    def forecast_mean_last_n(df: pd.DataFrame, player: str, stat: str, n: int = 5) -> float:
        """predict future stat using mean of last N games"""
        if df.empty:
            print("‚ö†Ô∏è forecast_mean_last_n: empty DataFrame")
            return 0.0

        player = clean_name(player)
        sub = df[df["player"].astype(str).str.title() == player]

        if stat not in sub.columns:
            print(f"‚ö†Ô∏è forecast_mean_last_n: missing stat '{stat}'")
            return 0.0

        if "week" in sub.columns:
            sub = sub.sort_values("week")
        elif "game_date" in sub.columns:
            sub = sub.sort_values("game_date")

        sub = sub.dropna(subset=[stat]).tail(n)
        if sub.empty:
            print(f"‚ö†Ô∏è forecast_mean_last_n: no recent data for {player}")
            return 0.0

        forecast = round(sub[stat].mean(), 2)
        print(f"üìà Forecast for {player} ({stat}): {forecast} (last {len(sub)} games)")
        return forecast


# ===============================================================
# CLASS 4: Visualizer
# ===============================================================
class Visualizer:
    """Handles leaderboard and player trend plots."""

    @staticmethod
    def leaderboard_plot(df: pd.DataFrame, stat: str, save_path: Optional[str] = None, show: bool = True):
        if df.empty or "player" not in df.columns or stat not in df.columns:
            print("‚ö†Ô∏è leaderboard_plot: bad or missing data")
            return

        with plt.style.context("default"):
            fig, ax = plt.subplots(figsize=(9, 5))
            ax.barh(df["player"], df[stat], color="skyblue")
            ax.set_title(f"Top {len(df)} Players by {stat.title()}", fontsize=14)
            ax.set_xlabel(stat.title(), fontsize=12)
            ax.invert_yaxis()
            plt.tight_layout()

            if save_path:
                try:
                    os.makedirs(os.path.dirname(save_path) or ".", exist_ok=True)
                    plt.savefig(save_path, dpi=150, bbox_inches="tight")
                    print(f"‚úÖ Saved plot: {save_path}")
                except Exception as e:
                    print(f"‚ùå Failed to save plot: {e}")

            if show:
                plt.show()
            else:
                plt.close()


# ===============================================================
# CLASS 5: Exporter
# ===============================================================
class Exporter:
    """Exports DataFrames to CSV or JSON files."""

    @staticmethod
    def to_csv(df: pd.DataFrame, path: str):
        if df.empty:
            print("‚ö†Ô∏è to_csv: empty DataFrame, nothing saved")
            return
        try:
            os.makedirs(os.path.dirname(path) or ".", exist_ok=True)
            df.to_csv(path, index=False)
            print(f"‚úÖ CSV saved to {path} ({len(df)} rows)")
        except Exception as e:
            print(f"‚ùå to_csv failed: {e}")

    @staticmethod
    def to_json(df: pd.DataFrame, path: str):
        if df.empty:
            print("‚ö†Ô∏è to_json: empty DataFrame, nothing saved")
            return
        try:
            os.makedirs(os.path.dirname(path) or ".", exist_ok=True)
            df.to_json(path, orient="records", indent=2)
            print(f"‚úÖ JSON saved to {path} ({len(df)} rows)")
        except Exception as e:
            print(f"‚ùå to_json failed: {e}")


# ===============================================================
# Demo / Quick Test
# ===============================================================
if __name__ == "__main__":
    demo_df = pd.DataFrame([
        {"player": "Patrick Mahomes", "team": "KC", "position": "QB", "season": 2024, "week": 1, "yards": 305, "td": 3, "plays": 35},
        {"player": "Patrick Mahomes", "team": "KC", "position": "QB", "season": 2024, "week": 2, "yards": 281, "td": 2, "plays": 32},
        {"player": "Tua Tagovailoa", "team": "MIA", "position": "QB", "season": 2024, "week": 1, "yards": 315, "td": 2, "plays": 33},
        {"player": "Tua Tagovailoa", "team": "MIA", "position": "QB", "season": 2024, "week": 2, "yards": 301, "td": 3, "plays": 34},
    ])

    p = Player("patrick  MAHOMES", team="KC", position="QB", games_df=demo_df[demo_df["player"] == "Patrick Mahomes"])
    print(p)
    print("Efficiency:", p.efficiency())

    ds = StatsDataset(demo_df)
    lb = ds.leaderboard(stat="yards", position="QB", season=2024, top_n=5)
    print("\nLeaderboard:")
    print(lb)

    rating = AnalyticsEngine.qb_rating(att=35, comp=25, yds=305, td=3, ints=0)
    print("\nQB Rating:", rating)

    forecast = AnalyticsEngine.forecast_mean_last_n(demo_df, "Patrick Mahomes", "yards", n=2)
    print("Forecast (Mahomes yards):", forecast)

    out_dir = "out"
    os.makedirs(out_dir, exist_ok=True)
    Exporter.to_csv(lb, os.path.join(out_dir, "qb_leaderboard.csv"))
    Exporter.to_json(lb, os.path.join(out_dir, "qb_leaderboard.json"))

    Visualizer.leaderboard_plot(lb, stat="yards", save_path=os.path.join(out_dir, "qb_leaderboard.png"), show=False)
    print("\nDemo finished.")