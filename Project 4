"""
NFL Analytics System - Project 4: Capstone Integration & Testing
INST326 Advanced OOP with Data Persistence

Team: Gridiron Data Systems (David, Dash, Andrew)

Complete system integrating Projects 1-3 with data persistence,
I/O capabilities and comprehensive testing.
"""

from __future__ import annotations
from typing import List, Optional, Dict, Any
from abc import ABC, abstractmethod
from pathlib import Path
import pandas as pd
import json
import csv

# ============================================================================
# CORE PLAYER CLASSES (From Project 3 - Inheritance & Polymorphism)
# ============================================================================

def clean_name(name: str) -> str:
    """Clean and standardize player names."""
    return str(name).strip()

VALID_TEAMS = {
    "ARI","ATL","BAL","BUF","CAR","CHI","CIN","CLE","DAL","DEN","DET","GB",
    "HOU","IND","JAX","KC","LV","LAC","LAR","MIA","MIN","NE","NO","NYG","NYJ",
    "PHI","PIT","SEA","SF","TB","TEN","WAS"
}

class Player(ABC):
    """Abstract base class for all NFL players."""
    
    def __init__(self, name: str, team: Optional[str], position: Optional[str]):
        self.name = clean_name(name)
        self.team = team
        self.position = position
        self.games_played = 0

    @abstractmethod
    def efficiency_score(self) -> float:
        """Calculate player efficiency score."""
        pass

    @abstractmethod
    def get_primary_stats(self) -> Dict[str, Any]:
        """Get the most important stats for this player type."""
        pass

    def to_dict(self) -> Dict[str, Any]:
        """Convert player to dictionary for persistence."""
        return {
            "name": self.name,
            "team": self.team,
            "position": self.position,
            "games_played": self.games_played,
            "player_type": self.__class__.__name__
        }

    def summary_row(self) -> Dict[str, object]:
        """Return a summary of player data for reports."""
        return {
            "name": self.name,
            "team": self.team,
            "position": self.position,
            "efficiency_score": round(self.efficiency_score(), 3),
            "games_played": self.games_played
        }

    def __str__(self) -> str:
        return f"{self.name} ({self.position}) - {self.team}"


class OffensivePlayer(Player):
    """Represents offensive players."""
    
    def __init__(self, name: str, team: Optional[str], position: Optional[str],
                 passing_yards: int = 0, rushing_yards: int = 0, 
                 receiving_yards: int = 0, touchdowns: int = 0, games_played: int = 0):
        super().__init__(name, team, position)
        self.passing_yards = passing_yards
        self.rushing_yards = rushing_yards
        self.receiving_yards = receiving_yards
        self.touchdowns = touchdowns
        self.games_played = games_played

    def efficiency_score(self) -> float:
        """Calculate offensive efficiency."""
        if self.games_played == 0:
            return 0.0
        yards_score = (
            self.passing_yards * 0.10 +
            self.rushing_yards * 0.20 +
            self.receiving_yards * 0.20
        )
        td_score = self.touchdowns * 6
        return (yards_score + td_score) / max(self.games_played, 1)

    def get_primary_stats(self) -> Dict[str, Any]:
        """Return offensive statistics."""
        return {
            "total_yards": self.passing_yards + self.rushing_yards + self.receiving_yards,
            "touchdowns": self.touchdowns,
            "yards_per_game": (self.passing_yards + self.rushing_yards + self.receiving_yards) / max(self.games_played, 1)
        }

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary including offensive stats."""
        d = super().to_dict()
        d.update({
            "passing_yards": self.passing_yards,
            "rushing_yards": self.rushing_yards,
            "receiving_yards": self.receiving_yards,
            "touchdowns": self.touchdowns
        })
        return d


class DefensivePlayer(Player):
    """Represents defensive players."""
    
    def __init__(self, name: str, team: Optional[str], position: Optional[str],
                 tackles: int = 0, sacks: int = 0, interceptions: int = 0, 
                 forced_fumbles: int = 0, games_played: int = 0):
        super().__init__(name, team, position)
        self.tackles = tackles
        self.sacks = sacks
        self.interceptions = interceptions
        self.forced_fumbles = forced_fumbles
        self.games_played = games_played

    def efficiency_score(self) -> float:
        """Calculate defensive efficiency."""
        if self.games_played == 0:
            return 0.0
        impact_score = (
            self.tackles * 0.5 +
            self.sacks * 3 +
            self.interceptions * 4 +
            self.forced_fumbles * 3.5
        )
        return impact_score / max(self.games_played, 1)

    def get_primary_stats(self) -> Dict[str, Any]:
        """Return defensive statistics."""
        return {
            "total_tackles": self.tackles,
            "big_plays": self.sacks + self.interceptions + self.forced_fumbles,
            "tackles_per_game": self.tackles / max(self.games_played, 1)
        }

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary including defensive stats."""
        d = super().to_dict()
        d.update({
            "tackles": self.tackles,
            "sacks": self.sacks,
            "interceptions": self.interceptions,
            "forced_fumbles": self.forced_fumbles
        })
        return d


class SpecialTeamsPlayer(Player):
    """Represents special teams players."""
    
    def __init__(self, name: str, team: Optional[str], position: Optional[str],
                 field_goals_made: int = 0, field_goals_attempted: int = 0,
                 punts_inside_20: int = 0, return_tds: int = 0, games_played: int = 0):
        super().__init__(name, team, position)
        self.field_goals_made = field_goals_made
        self.field_goals_attempted = field_goals_attempted
        self.punts_inside_20 = punts_inside_20
        self.return_tds = return_tds
        self.games_played = games_played

    def efficiency_score(self) -> float:
        """Calculate special teams efficiency."""
        if self.games_played == 0:
            return 0.0
        accuracy_bonus = 0
        if self.field_goals_attempted > 0:
            fg_percentage = self.field_goals_made / self.field_goals_attempted
            accuracy_bonus = fg_percentage * 5
        special_score = (
            self.field_goals_made * 2 +
            self.punts_inside_20 * 1.5 +
            self.return_tds * 6 +
            accuracy_bonus
        )
        return special_score / max(self.games_played, 1)

    def get_primary_stats(self) -> Dict[str, Any]:
        """Return special teams statistics."""
        fg_percentage = (self.field_goals_made / max(self.field_goals_attempted, 1)) * 100
        return {
            "field_goals_made": self.field_goals_made,
            "fg_percentage": round(fg_percentage, 1),
            "return_tds": self.return_tds,
            "punts_inside_20": self.punts_inside_20
        }

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary including special teams stats."""
        d = super().to_dict()
        d.update({
            "field_goals_made": self.field_goals_made,
            "field_goals_attempted": self.field_goals_attempted,
            "punts_inside_20": self.punts_inside_20,
            "return_tds": self.return_tds
        })
        return d

# ============================================================================
# TEAM & SEASON STATS (Composition)
# ============================================================================

class SeasonStats:
    """Track team-level season statistics."""
    
    def __init__(self):
        self.wins = 0
        self.losses = 0
        self.ties = 0
        self.points_scored = 0
        self.points_allowed = 0

    def add_game_result(self, points_for: int, points_against: int) -> None:
        """Record the result of a game."""
        self.points_scored += points_for
        self.points_allowed += points_against
        
        if points_for > points_against:
            self.wins += 1
        elif points_for < points_against:
            self.losses += 1
        else:
            self.ties += 1

    def win_percentage(self) -> float:
        """Calculate win percentage."""
        total_games = self.wins + self.losses + self.ties
        if total_games == 0:
            return 0.0
        return (self.wins + 0.5 * self.ties) / total_games

    def point_differential(self) -> int:
        """Calculate point differential."""
        return self.points_scored - self.points_allowed

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for persistence."""
        return {
            "wins": self.wins,
            "losses": self.losses,
            "ties": self.ties,
            "points_scored": self.points_scored,
            "points_allowed": self.points_allowed
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'SeasonStats':
        """Create from dictionary."""
        stats = cls()
        stats.wins = data.get("wins", 0)
        stats.losses = data.get("losses", 0)
        stats.ties = data.get("ties", 0)
        stats.points_scored = data.get("points_scored", 0)
        stats.points_allowed = data.get("points_allowed", 0)
        return stats

    def __str__(self) -> str:
        return f"Record: {self.wins}-{self.losses}-{self.ties} (Win%: {self.win_percentage():.3f})"


class Team:
    """Team with composition - HAS players and stats."""
    
    def __init__(self, name: str, abbreviation: str):
        abbr = abbreviation.upper()
        if abbr not in VALID_TEAMS:
            raise ValueError(f"Invalid team abbreviation: {abbr}")
        
        self.name = name
        self.abbreviation = abbr
        self.roster: List[Player] = []
        self.season_stats = SeasonStats()

    def add_player(self, player: Player) -> None:
        """Add a player to the team roster."""
        player.team = self.abbreviation
        if player not in self.roster:
            self.roster.append(player)

    def remove_player(self, player_name: str) -> bool:
        """Remove a player from the roster by name."""
        for i, player in enumerate(self.roster):
            if player.name.lower() == player_name.lower():
                del self.roster[i]
                return True
        return False

    def get_players_by_position(self, position: str) -> List[Player]:
        """Get all players at a specific position."""
        return [p for p in self.roster if p.position == position.upper()]

    def average_efficiency(self) -> float:
        """Calculate team's average player efficiency."""
        if not self.roster:
            return 0.0
        total_efficiency = sum(player.efficiency_score() for player in self.roster)
        return total_efficiency / len(self.roster)

    def to_dict(self) -> Dict[str, Any]:
        """Convert team to dictionary for persistence."""
        return {
            "name": self.name,
            "abbreviation": self.abbreviation,
            "roster": [p.to_dict() for p in self.roster],
            "season_stats": self.season_stats.to_dict()
        }

    def __str__(self) -> str:
        return f"{self.name} ({self.abbreviation}) - {len(self.roster)} players"

    def __len__(self) -> int:
        return len(self.roster)

# ============================================================================
# DATA PERSISTENCE MODULE (NEW)
# ============================================================================

class PersistanceManager: 
    """Handles saving and loading system state."""

    @staticmethod
    def save_teams_json(teams: List[Team], filepath: Path) -> None:
        """Save teams to JSON fuke with error handling"""
        try: 
            filepath.parent.mkdir(parents=True, exist_ok=True)
            data = {
                "teams": [team.to_dict() for team in teams],
                "count": len(teams)
            }
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2)
            print(f" Saved {len(teams)} teams to {filepath}")
        except IOError as e:
            raise IOError(f"Failed to save teams: {e}")

    @staticmethod
    def load_teams_json(filepath: Path) -> List[Team]:
        """Load teams from JSON file with error handling."""
        try:
            if not filepath.exists():
                raise FileNotFoundError(f"File not found: {filepath}")
            
            with open(filepath, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            teams = []
            for team_data in data.get("teams", []):
                team = Team(team_data["name"], team_data["abbreviation"])
                team.season_stats = SeasonStats.from_dict(team_data["season_stats"])
                
                # Recreate players based on type
                for player_data in team_data.get("roster", []):
                    player = PersistenceManager._create_player_from_dict(player_data)
                    team.add_player(player)
                
                teams.append(team)
            
            print(f" Loaded {len(teams)} teams from {filepath}")
            return teams
            
        except json.JSONDecodeError as e:
            raise ValueError(f"Invalid JSON format: {e}")
        except IOError as e:
            raise IOError(f"Failed to load teams: {e}")

    @staticmethod
    def _create_player_from_dict(data: Dict[str, Any]) -> Player:
        """Factory method to create player from dictionary."""
        player_type = data.get("player_type", "OffensivePlayer")
        name = data["name"]
        team = data.get("team")
        position = data.get("position")
        games = data.get("games_played", 0)
        
        if player_type == "OffensivePlayer":
            return OffensivePlayer(
                name, team, position,
                passing_yards=data.get("passing_yards", 0),
                rushing_yards=data.get("rushing_yards", 0),
                receiving_yards=data.get("receiving_yards", 0),
                touchdowns=data.get("touchdowns", 0),
                games_played=games
            )
        elif player_type == "DefensivePlayer":
            return DefensivePlayer(
                name, team, position,
                tackles=data.get("tackles", 0),
                sacks=data.get("sacks", 0),
                interceptions=data.get("interceptions", 0),
                forced_fumbles=data.get("forced_fumbles", 0),
                games_played=games
            )
        elif player_type == "SpecialTeamsPlayer":
            return SpecialTeamsPlayer(
                name, team, position,
                field_goals_made=data.get("field_goals_made", 0),
                field_goals_attempted=data.get("field_goals_attempted", 0),
                punts_inside_20=data.get("punts_inside_20", 0),
                return_tds=data.get("return_tds", 0),
                games_played=games
            )
        else:
            # Fallback to offensive player
            return OffensivePlayer(name, team, position, games_played=games)

    @staticmethod
    def export_leaderboard_csv(df: pd.DataFrame, filepath: Path) -> None:
        """Export leaderboard to CSV."""
        try:
            filepath.parent.mkdir(parents=True, exist_ok=True)
            df.to_csv(filepath, index=False)
            print(f" Exported leaderboard to {filepath}")
        except IOError as e:
            raise IOError(f"Failed to export CSV: {e}")

    @staticmethod
    def import_players_csv(filepath: Path) -> pd.DataFrame:
        """Import player data from CSV."""
        try:
            if not filepath.exists():
                raise FileNotFoundError(f"CSV file not found: {filepath}")
            
            df = pd.read_csv(filepath)
            required_cols = ["player", "team", "position"]
            missing = [col for col in required_cols if col not in df.columns]
            if missing:
                raise ValueError(f"CSV missing required columns: {missing}")
            
            print(f" Imported {len(df)} players from {filepath}")
            return df
            
        except pd.errors.EmptyDataError:
            raise ValueError("CSV file is empty")
        except IOError as e:
            raise IOError(f"Failed to import CSV: {e}")
