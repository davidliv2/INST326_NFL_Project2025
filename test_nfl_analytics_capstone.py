# -*- coding: utf-8 -*-
"""test_nfl_analytics_capstone.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UG4esmA1yO9HkIgx_6J45vyoWXJCDzdT
"""

"""
Test Suite for NFL Analytics Capstone - Project 4
INST326

Team: Gridiron Data Systems (David, Dash, Andrew)
"""

import unittest
import tempfile
import json
import pandas as pd
from pathlib import Path
import shutil
from unittest.mock import patch, MagicMock
import logging

# Disable logging during tests to reduce noise
logging.disable(logging.CRITICAL)

from nfl_analytics_capstone import (
    Player, OffensivePlayer, DefensivePlayer, SpecialTeamsPlayer,
    Team, SeasonStats, StatsDataset, AnalyticsEngine, NFLAnalyticsSystem,
    VALID_TEAMS, clean_name, DataPersistenceError, create_sample_data
)


class TestUnitTests(unittest.TestCase):
    """Unit tests for individual classes and methods."""

    def setUp(self):
        """Set up test players for unit testing."""
        self.qb = OffensivePlayer("Test QB", "BUF", "QB",
                                passing_yards=3000, touchdowns=25, games_played=16)
        self.linebacker = DefensivePlayer("Test LB", "BUF", "LB",
                                        tackles=80, sacks=5, games_played=16)
        self.kicker = SpecialTeamsPlayer("Test K", "BUF", "K",
                                       field_goals_made=25, field_goals_attempted=30, games_played=16)

    def test_player_inheritance(self):
        """Test that all player types inherit from Player properly."""
        self.assertIsInstance(self.qb, Player)
        self.assertIsInstance(self.linebacker, Player)
        self.assertIsInstance(self.kicker, Player)

        # Test specific subclass types
        self.assertIsInstance(self.qb, OffensivePlayer)
        self.assertIsInstance(self.linebacker, DefensivePlayer)
        self.assertIsInstance(self.kicker, SpecialTeamsPlayer)

    def test_efficiency_score_calculations(self):
        """Test that efficiency scores are calculated correctly for each player type."""
        # Test QB efficiency (should be positive with good stats)
        qb_score = self.qb.efficiency_score()
        self.assertGreater(qb_score, 0)
        self.assertIsInstance(qb_score, float)

        # Test LB efficiency
        lb_score = self.linebacker.efficiency_score()
        self.assertGreater(lb_score, 0)

        # Test K efficiency
        k_score = self.kicker.efficiency_score()
        self.assertGreater(k_score, 0)

        # All should be different values (polymorphic behavior)
        scores = [qb_score, lb_score, k_score]
        self.assertEqual(len(set(scores)), 3, "All efficiency scores should be different")

    def test_player_serialization(self):
        """Test player to_dict and from_dict methods."""
        # Test offensive player serialization
        qb_dict = self.qb.to_dict()
        self.assertIn("name", qb_dict)
        self.assertIn("player_type", qb_dict)
        self.assertEqual(qb_dict["player_type"], "OffensivePlayer")

        # Test deserialization
        qb_restored = Player.from_dict(qb_dict)
        self.assertEqual(qb_restored.name, self.qb.name)
        self.assertEqual(qb_restored.position, self.qb.position)
        self.assertIsInstance(qb_restored, OffensivePlayer)

    def test_team_validation(self):
        """Test team abbreviation validation."""
        # Valid team should work
        team = Team("Buffalo Bills", "BUF")
        self.assertEqual(team.abbreviation, "BUF")

        # Invalid team should raise error
        with self.assertRaises(ValueError):
            Team("Fake Team", "FAKE")

    def test_season_stats_tracking(self):
        """Test season statistics recording and calculations."""
        stats = SeasonStats()

        # Add some games
        stats.add_game_result(21, 14, "LAR", 1)  # Win
        stats.add_game_result(10, 17, "KC", 2)   # Loss
        stats.add_game_result(14, 14, "MIA", 3)  # Tie

        # Check records
        self.assertEqual(stats.wins, 1)
        self.assertEqual(stats.losses, 1)
        self.assertEqual(stats.ties, 1)

        # Check calculations
        self.assertEqual(stats.win_percentage(), 0.5)  # 1 win + 0.5 tie / 3 games
        self.assertEqual(stats.point_differential(), 4)  # 45 - 45 + 4


class TestDataPersistence(unittest.TestCase):
    """Test data persistence and I/O operations."""

    def setUp(self):
        """Set up temporary directory for file operations."""
        self.test_dir = tempfile.mkdtemp()
        self.test_path = Path(self.test_dir)

    def tearDown(self):
        """Clean up temporary files."""
        shutil.rmtree(self.test_dir, ignore_errors=True)

    def test_team_save_load(self):
        """Test saving and loading team data to/from JSON."""
        # Create a team with players
        team = Team("Buffalo Bills", "BUF")
        qb = OffensivePlayer("Josh Allen", "BUF", "QB", passing_yards=4000, touchdowns=30, games_played=16)
        wr = OffensivePlayer("Stefon Diggs", "BUF", "WR", receiving_yards=1400, touchdowns=10, games_played=16)
        team.add_player(qb)
        team.add_player(wr)

        # Add season stats
        team.season_stats.add_game_result(31, 10, "LAR", 1)
        team.season_stats.add_game_result(28, 25, "KC", 2)

        # Save team
        team_file = self.test_path / "bills.json"
        team.save_to_file(team_file)
        self.assertTrue(team_file.exists())

        # Load team
        loaded_team = Team.load_from_file(team_file)

        # Verify loaded data
        self.assertEqual(loaded_team.name, team.name)
        self.assertEqual(loaded_team.abbreviation, team.abbreviation)
        self.assertEqual(len(loaded_team.roster), 2)
        self.assertEqual(loaded_team.season_stats.wins, 2)
        self.assertEqual(loaded_team.season_stats.losses, 0)

    def test_csv_import_export(self):
        """Test CSV import and export functionality."""
        # Create sample data
        sample_df = create_sample_data()

        # Save to CSV
        csv_file = self.test_path / "test_stats.csv"
        sample_df.to_csv(csv_file, index=False)

        # Import from CSV
        dataset = StatsDataset.from_csv(csv_file)
        self.assertGreater(len(dataset._df), 0)

        # Test that we can build teams from imported data
        bills = dataset.build_team_roster("BUF")
        self.assertGreater(len(bills.roster), 0)

        # Export back to CSV
        export_file = self.test_path / "exported_stats.csv"
        dataset.export_to_csv(export_file, [bills])
        self.assertTrue(export_file.exists())

    def test_json_import(self):
        """Test importing data from JSON files."""
        # Create JSON test data
        json_data = {
            "players": [
                {
                    "player": "Test Player",
                    "team": "BUF",
                    "position": "QB",
                    "passing_yards": 3000,
                    "touchdowns": 20,
                    "games_played": 16
                }
            ]
        }

        json_file = self.test_path / "test_data.json"
        with open(json_file, 'w') as f:
            json.dump(json_data, f)

        # Import JSON data
        dataset = StatsDataset.from_json(json_file)
        self.assertEqual(len(dataset._df), 1)
        self.assertEqual(dataset._df.iloc[0]["player"], "Test Player")

    def test_error_handling_missing_files(self):
        """Test error handling for missing files."""
        non_existent_file = self.test_path / "does_not_exist.json"

        # Should raise DataPersistenceError for missing team file
        with self.assertRaises(DataPersistenceError):
            Team.load_from_file(non_existent_file)

        # Should raise DataPersistenceError for missing CSV
        with self.assertRaises(DataPersistenceError):
            StatsDataset.from_csv(non_existent_file)

    def test_corrupted_data_handling(self):
        """Test handling of corrupted data files."""
        # Create corrupted JSON file
        corrupted_file = self.test_path / "corrupted.json"
        with open(corrupted_file, 'w') as f:
            f.write("{ invalid json content")

        with self.assertRaises(DataPersistenceError):
            Team.load_from_file(corrupted_file)


class TestIntegrationTests(unittest.TestCase):
    """Integration tests for class coordination and interaction."""

    def setUp(self):
        """Set up integration test environment."""
        self.test_dir = tempfile.mkdtemp()
        self.test_path = Path(self.test_dir)

        # Create sample dataset
        self.sample_df = create_sample_data()
        self.dataset = StatsDataset(self.sample_df)

    def tearDown(self):
        """Clean up test environment."""
        shutil.rmtree(self.test_dir, ignore_errors=True)

    def test_dataset_team_integration(self):
        """Test integration between StatsDataset and Team classes."""
        # Build team from dataset
        bills = self.dataset.build_team_roster("BUF")
        rams = self.dataset.build_team_roster("LAR")

        # Verify teams were built correctly
        self.assertGreater(len(bills.roster), 0)
        self.assertGreater(len(rams.roster), 0)

        # All players should have correct team assignment
        for player in bills.roster:
            self.assertEqual(player.team, "BUF")

        for player in rams.roster:
            self.assertEqual(player.team, "LAR")

    def test_team_analytics_integration(self):
        """Test integration between Team and AnalyticsEngine."""
        # Create teams
        bills = self.dataset.build_team_roster("BUF")
        rams = self.dataset.build_team_roster("LAR")

        # Test team rankings
        rankings = AnalyticsEngine.rank_teams([bills, rams])
        self.assertEqual(len(rankings), 2)
        self.assertIn("rank", rankings.columns)
        self.assertIn("avg_efficiency", rankings.columns)

        # Test player rankings across teams
        all_players = bills.roster + rams.roster
        player_rankings = AnalyticsEngine.rank_players(all_players)
        self.assertGreater(len(player_rankings), 0)

    def test_team_season_stats_integration(self):
        """Test integration between Team and SeasonStats."""
        team = Team("Buffalo Bills", "BUF")

        # Add some players
        qb = OffensivePlayer("QB1", "BUF", "QB", touchdowns=30, games_played=16)
        team.add_player(qb)

        # Add game results
        team.season_stats.add_game_result(28, 21, "LAR", 1)
        team.season_stats.add_game_result(35, 14, "MIA", 2)

        # Test team summary integration
        summary = team.get_team_summary()
        self.assertIn("team_name", summary)
        self.assertIn("record", summary)
        self.assertEqual(summary["total_players"], 1)

    def test_player_polymorphism_integration(self):
        """Test polymorphic behavior across different player types."""
        # Create mixed list of players
        players = [
            OffensivePlayer("QB1", "BUF", "QB", passing_yards=4000, touchdowns=30, games_played=16),
            DefensivePlayer("LB1", "BUF", "LB", tackles=100, sacks=10, games_played=16),
            SpecialTeamsPlayer("K1", "BUF", "K", field_goals_made=25, field_goals_attempted=28, games_played=16)
        ]

        # Test that analytics engine handles all types uniformly
        rankings = AnalyticsEngine.rank_players(players)
        self.assertEqual(len(rankings), 3)

        # Each player should have different stats but same interface
        for player in players:
            score = player.efficiency_score()
            stats = player.get_primary_stats()
            self.assertIsInstance(score, float)
            self.assertIsInstance(stats, dict)

    def test_data_flow_integration(self):
        """Test data flow from import to analysis to export."""
        # Save sample data to CSV
        csv_file = self.test_path / "sample_data.csv"
        self.sample_df.to_csv(csv_file, index=False)

        # Import data
        dataset = StatsDataset.from_csv(csv_file)

        # Build teams
        bills = dataset.build_team_roster("BUF")
        rams = dataset.build_team_roster("LAR")

        # Generate analytics
        team_rankings = AnalyticsEngine.rank_teams([bills, rams])

        # Export results
        export_file = self.test_path / "rankings_export.csv"
        AnalyticsEngine.export_rankings_report([bills, rams], export_file)

        # Verify files were created
        expected_files = [
            self.test_path / "rankings_export_team_rankings.csv",
            self.test_path / "rankings_export_player_rankings.csv"
        ]
        for file_path in expected_files:
            self.assertTrue(file_path.exists())

    def test_system_persistence_integration(self):
        """Test integration of system-wide persistence."""
        system = NFLAnalyticsSystem()
        system.system_data_path = self.test_path / "nfl_data"

        # Create and add teams
        bills = self.dataset.build_team_roster("BUF")
        rams = self.dataset.build_team_roster("LAR")

        system.teams["BUF"] = bills
        system.teams["LAR"] = rams

        # Save all teams
        system.save_all_teams()

        # Verify files exist
        bills_file = system.system_data_path / "buf_team.json"
        rams_file = system.system_data_path / "lar_team.json"
        self.assertTrue(bills_file.exists())
        self.assertTrue(rams_file.exists())

        # Test loading teams
        loaded_bills = system.load_team_data("BUF")
        self.assertEqual(loaded_bills.name, bills.name)

    def test_error_propagation_integration(self):
        """Test that errors propagate properly across integrated components."""
        # Test invalid team handling throughout system
        with self.assertRaises(ValueError):
            self.dataset.build_team_roster("INVALID")

        # Test file I/O error handling in system context
        system = NFLAnalyticsSystem()
        system.system_data_path = Path("/invalid/path/that/cannot/be/created")

        with self.assertRaises(DataPersistenceError):
            team = Team("Test Team", "BUF")
            team.save_to_file(system.system_data_path / "test.json")

    def test_analytics_export_integration(self):
        """Test integration between analytics generation and export."""
        # Build teams
        teams = [
            self.dataset.build_team_roster("BUF"),
            self.dataset.build_team_roster("LAR")
        ]

        # Generate and export rankings
        export_path = self.test_path / "test_rankings.csv"
        AnalyticsEngine.export_rankings_report(teams, export_path)

        # Verify exported files have content
        team_file = self.test_path / "test_rankings_team_rankings.csv"
        player_file = self.test_path / "test_rankings_player_rankings.csv"

        self.assertTrue(team_file.exists())
        self.assertTrue(player_file.exists())

        # Verify content
        team_df = pd.read_csv(team_file)
        player_df = pd.read_csv(player_file)
        self.assertGreater(len(team_df), 0)
        self.assertGreater(len(player_df), 0)


class TestSystemTests(unittest.TestCase):
    """System tests for complete end-to-end workflows."""

    def setUp(self):
        """Set up system test environment."""
        self.test_dir = tempfile.mkdtemp()
        self.test_path = Path(self.test_dir)
        self.system = NFLAnalyticsSystem()
        self.system.system_data_path = self.test_path / "nfl_data"

    def tearDown(self):
        """Clean up system test environment."""
        shutil.rmtree(self.test_dir, ignore_errors=True)

    def test_complete_data_import_workflow(self):
        """Test complete workflow from data import to team creation."""
        # Create sample data file
        sample_data = create_sample_data()
        csv_file = self.test_path / "sample_stats.csv"
        sample_data.to_csv(csv_file, index=False)

        # Import data through system
        self.system.import_weekly_stats(csv_file)

        # Verify teams were created
        self.assertIn("BUF", self.system.teams)
        self.assertIn("LAR", self.system.teams)

        # Verify teams have players
        bills = self.system.teams["BUF"]
        rams = self.system.teams["LAR"]
        self.assertGreater(len(bills.roster), 0)
        self.assertGreater(len(rams.roster), 0)

    def test_complete_analysis_workflow(self):
        """Test complete analysis and reporting workflow."""
        # Set up teams with data
        sample_data = create_sample_data()
        dataset = StatsDataset(sample_data)

        bills = dataset.build_team_roster("BUF")
        rams = dataset.build_team_roster("LAR")

        # Add game results for realistic analysis
        bills.season_stats.add_game_result(31, 10, "LAR", 1)
        bills.season_stats.add_game_result(28, 25, "KC", 2)
        rams.season_stats.add_game_result(10, 31, "BUF", 1)
        rams.season_stats.add_game_result(24, 17, "SF", 2)

        self.system.teams = {"BUF": bills, "LAR": rams}

        # Generate complete league report
        report_file = self.test_path / "league_report.json"
        self.system.generate_league_report(report_file)

        # Verify report was created and has content
        self.assertTrue(report_file.exists())

        with open(report_file, 'r') as f:
            report = json.load(f)

        # Check report structure
        self.assertIn("generation_time", report)
        self.assertIn("total_teams", report)
        self.assertIn("team_rankings", report)
        self.assertIn("top_players_by_position", report)
        self.assertIn("league_stats", report)

        # Verify content
        self.assertEqual(report["total_teams"], 2)
        self.assertGreater(len(report["team_rankings"]), 0)

    def test_save_load_restore_workflow(self):
        """Test complete save, load, and restore workflow."""
        # Create teams with comprehensive data
        sample_data = create_sample_data()
        dataset = StatsDataset(sample_data)

        bills = dataset.build_team_roster("BUF")
        rams = dataset.build_team_roster("LAR")

        # Add detailed season data
        bills.season_stats.add_game_result(31, 10, "LAR", 1)
        bills.season_stats.add_game_result(28, 25, "KC", 2)
        bills.season_stats.add_game_result(17, 20, "NE", 3)

        # Store in system and save
        self.system.teams = {"BUF": bills, "LAR": rams}
        self.system.save_all_teams()

        # Create new system instance (simulating program restart)
        new_system = NFLAnalyticsSystem()
        new_system.system_data_path = self.system.system_data_path

        # Load teams
        loaded_bills = new_system.load_team_data("BUF")
        loaded_rams = new_system.load_team_data("LAR")

        # Verify all data was preserved
        self.assertEqual(loaded_bills.name, bills.name)
        self.assertEqual(len(loaded_bills.roster), len(bills.roster))
        self.assertEqual(loaded_bills.season_stats.wins, 2)
        self.assertEqual(loaded_bills.season_stats.losses, 1)

        # Verify individual player data
        original_qb = next(p for p in bills.roster if p.position == "QB")
        loaded_qb = next(p for p in loaded_bills.roster if p.position == "QB")
        self.assertEqual(original_qb.name, loaded_qb.name)
        self.assertEqual(original_qb.efficiency_score(), loaded_qb.efficiency_score())

    def test_error_recovery_workflow(self):
        """Test system behavior under error conditions."""
        # Test recovery from missing data files
        missing_team = self.system.load_team_data("KC")  # Should create new team
        self.assertIsNotNone(missing_team)
        self.assertEqual(missing_team.abbreviation, "KC")

        # Test handling of invalid data during import
        bad_csv_content = "invalid,csv,header\n1,2,3\n4,5,6"
        bad_csv_file = self.test_path / "bad_data.csv"
        with open(bad_csv_file, 'w') as f:
            f.write(bad_csv_content)

        with self.assertRaises(DataPersistenceError):
            self.system.import_weekly_stats(bad_csv_file)

    def test_multi_week_update_workflow(self):
        """Test workflow for updating teams with multiple weeks of data."""
        # Week 1 data
        week1_data = pd.DataFrame({
            "player": ["Josh Allen", "Stefon Diggs"],
            "team": ["BUF", "BUF"],
            "position": ["QB", "WR"],
            "passing_yards": [300, 0],
            "receiving_yards": [0, 100],
            "touchdowns": [2, 1],
            "games_played": [1, 1]
        })

        # Week 2 data (cumulative stats)
        week2_data = pd.DataFrame({
            "player": ["Josh Allen", "Stefon Diggs"],
            "team": ["BUF", "BUF"],
            "position": ["QB", "WR"],
            "passing_yards": [650, 0],
            "receiving_yards": [0, 220],
            "touchdowns": [5, 2],
            "games_played": [2, 2]
        })

        # Import week 1
        week1_file = self.test_path / "week1.csv"
        week1_data.to_csv(week1_file, index=False)
        self.system.import_weekly_stats(week1_file)

        # Get initial stats
        bills_w1 = self.system.teams["BUF"]
        qb_w1 = next(p for p in bills_w1.roster if p.position == "QB")
        initial_efficiency = qb_w1.efficiency_score()

        # Import week 2 (would need update logic in real system)
        week2_file = self.test_path / "week2.csv"
        week2_data.to_csv(week2_file, index=False)

        # For this test, simulate by creating new dataset
        dataset_w2 = StatsDataset.from_csv(week2_file)
        bills_w2 = dataset_w2.build_team_roster("BUF")

        # Verify stats improved
        qb_w2 = next(p for p in bills_w2.roster if p.position == "QB")
        updated_efficiency = qb_w2.efficiency_score()
        self.assertGreater(updated_efficiency, initial_efficiency)


class TestFileIOEdgeCases(unittest.TestCase):
    """Test edge cases and error conditions for file I/O."""

    def setUp(self):
        """Set up file I/O test environment."""
        self.test_dir = tempfile.mkdtemp()
        self.test_path = Path(self.test_dir)

    def tearDown(self):
        """Clean up file I/O test environment."""
        shutil.rmtree(self.test_dir, ignore_errors=True)

    def test_empty_csv_handling(self):
        """Test handling of empty CSV files."""
        empty_csv = self.test_path / "empty.csv"
        with open(empty_csv, 'w') as f:
            f.write("")  # Completely empty file

        with self.assertRaises(DataPersistenceError):
            StatsDataset.from_csv(empty_csv)

    def test_partial_data_csv(self):
        """Test handling of CSV with missing columns."""
        partial_csv = self.test_path / "partial.csv"
        partial_data = pd.DataFrame({
            "player": ["Test Player"],
            "team": ["BUF"]
            # Missing position column
        })
        partial_data.to_csv(partial_csv, index=False)

        with self.assertRaises(ValueError):
            StatsDataset.from_csv(partial_csv)

    def test_large_dataset_handling(self):
        """Test system performance with larger datasets."""
        # Create larger dataset
        large_data = []
        for i in range(100):
            large_data.append({
                "player": f"Player {i}",
                "team": "BUF" if i % 2 == 0 else "LAR",
                "position": "QB" if i % 10 == 0 else "WR",
                "passing_yards": i * 10,
                "receiving_yards": i * 5,
                "touchdowns": i // 10,
                "games_played": 16
            })

        large_df = pd.DataFrame(large_data)
        large_csv = self.test_path / "large_dataset.csv"
        large_df.to_csv(large_csv, index=False)

        # Test import and processing
        dataset = StatsDataset.from_csv(large_csv)
        bills = dataset.build_team_roster("BUF")

        # Should handle large roster
        self.assertGreater(len(bills.roster), 20)

        # Analytics should still work
        player_rankings = AnalyticsEngine.rank_players(bills.roster, top_n=10)
        self.assertEqual(len(player_rankings), 10)


def run_all_tests():
    """Run all test suites and provide summary."""
    print("NFL Analytics System - Comprehensive Test Suite")
    print("=" * 60)

    # Create test suite
    test_suite = unittest.TestSuite()

    # Add all test classes
    test_classes = [
        TestUnitTests,
        TestDataPersistence,
        TestIntegrationTests,
        TestSystemTests,
        TestFileIOEdgeCases
    ]

    for test_class in test_classes:
        tests = unittest.TestLoader().loadTestsFromTestCase(test_class)
        test_suite.addTests(tests)

    # Run tests with detailed output
    runner = unittest.TextTestRunner(verbosity=2, stream=None)
    result = runner.run(test_suite)

    # Print comprehensive summary
    print(f"\n{'='*60}")
    print(f"TESTING SUMMARY - PROJECT 4 CAPSTONE")
    print(f"{'='*60}")
    print(f"Tests run: {result.testsRun}")
    print(f"Failures: {len(result.failures)}")
    print(f"Errors: {len(result.errors)}")
    print(f"Success rate: {((result.testsRun - len(result.failures) - len(result.errors)) / result.testsRun * 100):.1f}%")

    if result.wasSuccessful():
        print("ALL TESTS PASSED!")
        print("System ready for production use")
    else:
        print("Some tests failed. Check output above.")

        if result.failures:
            print(f"\nFailures ({len(result.failures)}):")
            for test, traceback in result.failures:
                print(f"  • {test}")

        if result.errors:
            print(f"\nErrors ({len(result.errors)}):")
            for test, traceback in result.errors:
                print(f"  • {test}")

    # Test coverage summary
    print(f"TEST COVERAGE SUMMARY:")
    print(f"Unit Tests: Individual class methods and functionality")
    print(f"Integration Tests: {len(unittest.TestLoader().loadTestsFromTestCase(TestIntegrationTests)._tests)} tests covering class interactions")
    print(f"System Tests: {len(unittest.TestLoader().loadTestsFromTestCase(TestSystemTests)._tests)} tests covering complete workflows")
    print(f"I/O Tests: Data persistence and file handling")
    print(f"Error Handling: Edge cases and error recovery")

    return result.wasSuccessful()


if __name__ == "__main__":
    success = run_all_tests()
    exit(0 if success else 1)