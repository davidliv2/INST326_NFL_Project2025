"""
Project 3
Team: Gridiron Data Systems (David, Dash, Andrew)
Course: INST326
"""

from typing import List, Dict, Optional
from player import Player  

# Team
class Team:
    """A team has a roster of Player objects (composition)."""
    
    def __init__(self, name: str, abbreviation: str):
        if abbreviation.upper() not in VALID_TEAMS:
            raise ValueError(f"Invalid team abbreviation: {abbreviation}")
        self.name = name
        self.abbreviation = abbreviation.upper()
        self.roster: List[Player] = []  # Composition: Team HAS players
    
    def add_player(self, player: Player) -> None:
        if player.team and player.team != self.abbreviation:
            print(f"Warning: {player.name} is already on {player.team}, updating to {self.abbreviation}")
        player.team = self.abbreviation
        if player not in self.roster:
            self.roster.append(player)
    
    def remove_player(self, player_name: str) -> bool:
        for p in self.roster:
            if p.name == clean_name(player_name):
                self.roster.remove(p)
                return True
        return False
    
    def get_players_by_position(self, position: str) -> List[Player]:
        return [p for p in self.roster if p.position and p.position.upper() == position.upper()]
    
    def get_offense(self) -> List[Player]:
        offense_positions = {"QB", "RB", "WR", "TE", "OL", "FB"}
        return [p for p in self.roster if p.position in offense_positions]
    
    def get_defense(self) -> List[Player]:
        defense_positions = {"DL", "LB", "CB", "S"}
        return [p for p in self.roster if p.position in defense_positions]
    
    def get_special_teams(self) -> List[Player]:
        return [p for p in self.roster if p.position in {"K", "P"}]
    
    def __str__(self):
        return f"{self.name} ({self.abbreviation}) - {len(self.roster)} players"
    
    def __len__(self):
        return len(self.roster)

# Stats Dataset
def add_player_from_row(self, row: pd.Series) -> Player:
    """Create a Player object from a DataFrame row and add to internal tracking if desired."""
    from player import OffensivePlayer, DefensivePlayer, SpecialTeamsPlayer  # Adjust based on actual subclasses
    
    name = clean_name(row.get("player", ""))
    team = row.get("team")
    pos = row.get("position", "").upper()
    
    # You'll decide mapping logic with Person A
    if pos in {"QB", "RB", "WR", "TE"}:
        player = OffensivePlayer(name=name, team=team, position=pos)
    elif pos in {"DL", "LB", "CB", "S"}:
        player = DefensivePlayer(name=name, team=team, position=pos)
    elif pos in {"K", "P"}:
        player = SpecialTeamsPlayer(name=name, team=team, position=pos)
    else:
        player = Player(name=name, team=team, position=pos)  # fallback
    
    # Optionally attach game log
    player.games_df = self._df[self._df["player"] == row["player"]]
    return player

def build_roster(self, team_abbr: str) -> Team:
    """Build a full Team object from the dataset."""
    team_data = self._df[self._df["team"] == team_abbr.upper()]
    if team_data.empty:
        raise ValueError(f"No data for team {team_abbr}")
    
    from team import Team
    team_name = dict(zip(VALID_TEAMS, VALID_TEAMS))  # Replaces with real name mapping
    team = Team(name=f"{team_abbr} Team", abbreviation=team_abbr)
    
    seen = set()
    for _, row in team_data.iterrows():
        name = clean_name(row["player"])
        if name in seen:
            continue
        seen.add(name)
        player = self.add_player_from_row(row)
        team.add_player(player)
    
    return team

# Analytics Engine
@staticmethod
def rank_players(players: List[Player], stat_key: str = "efficiency_score", top_n: int = 10) -> pd.DataFrame:
    """
    Polymorphic ranking! Works with any Player subclass that implements efficiency_score() or summary_row()
    """
    ranked = []
    for player in players:
        try:
            if hasattr(player, stat_key) and callable(getattr(player, stat_key)):
                score = getattr(player, stat_key)()
            elif hasattr(player, "summary_row"):
                score = player.summary_row().get("value", 0)
            else:
                score = 0.0
            ranked.append({"player": player.name, "team": player.team or "FA", "position": player.position or "N/A", "value": score})
        except Exception as e:
            print(f"Error scoring {player.name}: {e}")
            continue
    
    df = pd.DataFrame(ranked)
    if df.empty:
        return df
    
    df = df.sort_values("value", ascending=False).head(top_n)
    df.insert(0, "rank", range(1, len(df) + 1))
    df = df[["rank", "player", "position", "team", "value"]]
    df.columns = ["Rank", "Player", "Position", "Team", stat_key.replace("_", " ").title()]
    return df.reset_index(drop=True)

@staticmethod
def team_power_ranking(teams: List[Team], stat_key: str = "efficiency_score") -> pd.DataFrame:
    """Rank entire teams by average player efficiency (or any polymorphic stat)"""
    results = []
    for team in teams:
        scores = []
        for player in team.roster:
            if hasattr(player, stat_key) and callable(getattr(player, stat_key)):
                try:
                    scores.append(getattr(player, stat_key)())
                except:
                    continue
        avg = sum(scores) / len(scores) if scores else 0.0
        results.append({"team": team.abbreviation, "name": team.name, "avg_score": round(avg, 3), "roster_size": len(team)})
    
    df = pd.DataFrame(results).sort_values("avg_score", ascending=False)
    df.insert(0, "rank", range(1, len(df) + 1))
    return df
