"""
NFL Analytics System - Project 3
INST326 Advanced OOP with Inheritance & Polymorphism

Team: Gridiron Data Systems (David, Dash, Andrew)

This system demonstrates inheritance hierarchies, polymorphism, and composition
for analyzing NFL player and team performance data.
"""

from __future__ import annotations
from typing import List, Optional, Dict, Any
from abc import ABC, abstractmethod
import pandas as pd

def clean_name(name: str) -> str:
    """Clean and standardize player names."""
    return str(name).strip()

# Valid NFL team abbreviations
VALID_TEAMS = {
    "ARI","ATL","BAL","BUF","CAR","CHI","CIN","CLE","DAL","DEN","DET","GB",
    "HOU","IND","JAX","KC","LV","LAC","LAR","MIA","MIN","NE","NO","NYG","NYJ",
    "PHI","PIT","SEA","SF","TB","TEN","WAS"
}

# Player Inheritance Hierarchy


class Player(ABC):
    """
    Abstract base class for all NFL players.
    Demonstrates inheritance hierarchy with polymorphic behavior.
    """
    
    def __init__(self, name: str, team: Optional[str], position: Optional[str]):
        self.name = clean_name(name)
        self.team = team
        self.position = position
        self.games_played = 0  # Added for more realistic player tracking

    @abstractmethod
    def efficiency_score(self) -> float:
        """Calculate player efficiency score - must be implemented by subclasses."""
        pass

    @abstractmethod
    def get_primary_stats(self) -> Dict[str, Any]:
        """Get the most important stats for this player type."""
        pass

    def summary_row(self) -> Dict[str, object]:
        """Return a summary of player data for reports."""
        return {
            "name": self.name,
            "team": self.team,
            "position": self.position,
            "efficiency_score": round(self.efficiency_score(), 3),
            "games_played": self.games_played
        }

    def __str__(self) -> str:
        return f"{self.name} ({self.position}) - {self.team}"

    def __repr__(self) -> str:
        return f"Player('{self.name}', '{self.team}', '{self.position}')"


class OffensivePlayer(Player):
    """Represents offensive players (QB, RB, WR, TE)."""
    
    def __init__(self, name: str, team: Optional[str], position: Optional[str],
                 passing_yards: int = 0, rushing_yards: int = 0, 
                 receiving_yards: int = 0, touchdowns: int = 0, games_played: int = 0):
        super().__init__(name, team, position)
        self.passing_yards = passing_yards
        self.rushing_yards = rushing_yards
        self.receiving_yards = receiving_yards
        self.touchdowns = touchdowns
        self.games_played = games_played

    def efficiency_score(self) -> float:
        """Calculate offensive efficiency based on yards and touchdowns."""
        if self.games_played == 0:
            return 0.0
            
        # Weight different types of yards differently
        yards_score = (
            self.passing_yards * 0.10 +    # Passing yards worth less (volume stat)
            self.rushing_yards * 0.20 +    # Rushing yards more valuable
            self.receiving_yards * 0.20    # Receiving yards equally valuable
        )
        td_score = self.touchdowns * 6     # Touchdowns are highly valuable
        
        # Normalize by games played for fair comparison
        return (yards_score + td_score) / max(self.games_played, 1)

    def get_primary_stats(self) -> Dict[str, Any]:
        """Return the most relevant offensive statistics."""
        return {
            "total_yards": self.passing_yards + self.rushing_yards + self.receiving_yards,
            "touchdowns": self.touchdowns,
            "yards_per_game": (self.passing_yards + self.rushing_yards + self.receiving_yards) / max(self.games_played, 1)
        }


class DefensivePlayer(Player):
    """Represents defensive players (DL, LB, CB, S)."""
    
    def __init__(self, name: str, team: Optional[str], position: Optional[str],
                 tackles: int = 0, sacks: int = 0, interceptions: int = 0, 
                 forced_fumbles: int = 0, games_played: int = 0):
        super().__init__(name, team, position)
        self.tackles = tackles
        self.sacks = sacks
        self.interceptions = interceptions
        self.forced_fumbles = forced_fumbles  # Added for more comprehensive defense stats
        self.games_played = games_played

    def efficiency_score(self) -> float:
        """Calculate defensive efficiency based on impact plays."""
        if self.games_played == 0:
            return 0.0
            
        # Impact plays weighted by game-changing potential
        impact_score = (
            self.tackles * 0.5 +           # Basic tackles
            self.sacks * 3 +               # Sacks are big plays
            self.interceptions * 4 +       # Turnovers are crucial
            self.forced_fumbles * 3.5      # Forced fumbles create opportunities
        )
        
        return impact_score / max(self.games_played, 1)

    def get_primary_stats(self) -> Dict[str, Any]:
        """Return the most relevant defensive statistics."""
        return {
            "total_tackles": self.tackles,
            "big_plays": self.sacks + self.interceptions + self.forced_fumbles,
            "tackles_per_game": self.tackles / max(self.games_played, 1)
        }


class SpecialTeamsPlayer(Player):
    """Represents special teams players (K, P, Return specialists)."""
    
    def __init__(self, name: str, team: Optional[str], position: Optional[str],
                 field_goals_made: int = 0, field_goals_attempted: int = 0,
                 punts_inside_20: int = 0, return_tds: int = 0, games_played: int = 0):
        super().__init__(name, team, position)
        self.field_goals_made = field_goals_made
        self.field_goals_attempted = field_goals_attempted
        self.punts_inside_20 = punts_inside_20
        self.return_tds = return_tds
        self.games_played = games_played

    def efficiency_score(self) -> float:
        """Calculate special teams efficiency based on accuracy and impact."""
        if self.games_played == 0:
            return 0.0
            
        # Accuracy component for kickers
        accuracy_bonus = 0
        if self.field_goals_attempted > 0:
            fg_percentage = self.field_goals_made / self.field_goals_attempted
            accuracy_bonus = fg_percentage * 5  # Bonus for accuracy
        
        # Base scoring
        special_score = (
            self.field_goals_made * 2 +        # Made field goals
            self.punts_inside_20 * 1.5 +       # Punting precision
            self.return_tds * 6 +              # Return touchdowns are rare and valuable
            accuracy_bonus
        )
        
        return special_score / max(self.games_played, 1)

    def get_primary_stats(self) -> Dict[str, Any]:
        """Return the most relevant special teams statistics."""
        fg_percentage = (self.field_goals_made / max(self.field_goals_attempted, 1)) * 100
        return {
            "field_goals_made": self.field_goals_made,
            "fg_percentage": round(fg_percentage, 1),
            "return_tds": self.return_tds,
            "punts_inside_20": self.punts_inside_20
        }



# Composition Classes


class Team:
    """
    Demonstrates composition - a Team HAS players (has-a relationship).
    This is composition rather than inheritance because a Team is not a type of Player.
    """
    
    def __init__(self, name: str, abbreviation: str):
        # Validate team abbreviation
        abbr = abbreviation.upper()
        if abbr not in VALID_TEAMS:
            raise ValueError(f"Invalid team abbreviation: {abbr}")
        
        self.name = name
        self.abbreviation = abbr
        self.roster: List[Player] = []  # Composition: Team contains Players
        self.season_stats = SeasonStats()  # Composition: Team has SeasonStats

    def add_player(self, player: Player) -> None:
        """Add a player to the team roster."""
        player.team = self.abbreviation  # Update player's team reference
        if player not in self.roster:
            self.roster.append(player)

    def remove_player(self, player_name: str) -> bool:
        """Remove a player from the roster by name."""
        for i, player in enumerate(self.roster):
            if player.name.lower() == player_name.lower():
                del self.roster[i]
                return True
        return False

    def get_players_by_position(self, position: str) -> List[Player]:
        """Get all players at a specific position."""
        return [p for p in self.roster if p.position == position.upper()]

    def average_efficiency(self) -> float:
        """Calculate team's average player efficiency."""
        if not self.roster:
            return 0.0
        total_efficiency = sum(player.efficiency_score() for player in self.roster)
        return total_efficiency / len(self.roster)

    def get_team_summary(self) -> Dict[str, Any]:
        """Get comprehensive team statistics."""
        if not self.roster:
            return {"error": "No players on roster"}
        
        position_counts = {}
        for player in self.roster:
            pos = player.position or "Unknown"
            position_counts[pos] = position_counts.get(pos, 0) + 1
        
        return {
            "team_name": self.name,
            "abbreviation": self.abbreviation,
            "total_players": len(self.roster),
            "average_efficiency": round(self.average_efficiency(), 3),
            "positions": position_counts,
            "top_player": max(self.roster, key=lambda p: p.efficiency_score()).name if self.roster else None
        }

    def __str__(self) -> str:
        return f"{self.name} ({self.abbreviation}) â€” {len(self.roster)} players"

    def __len__(self) -> int:
        return len(self.roster)


class SeasonStats:
    """
    Composition class to track team-level season statistics.
    Demonstrates has-a relationship with Team.
    """
    
    def __init__(self):
        self.wins = 0
        self.losses = 0
        self.ties = 0
        self.points_scored = 0
        self.points_allowed = 0

    def add_game_result(self, points_for: int, points_against: int) -> None:
        """Record the result of a game."""
        self.points_scored += points_for
        self.points_allowed += points_against
        
        if points_for > points_against:
            self.wins += 1
        elif points_for < points_against:
            self.losses += 1
        else:
            self.ties += 1

    def win_percentage(self) -> float:
        """Calculate win percentage."""
        total_games = self.wins + self.losses + self.ties
        if total_games == 0:
            return 0.0
        return (self.wins + 0.5 * self.ties) / total_games

    def point_differential(self) -> int:
        """Calculate point differential."""
        return self.points_scored - self.points_allowed

    def __str__(self) -> str:
        return f"Record: {self.wins}-{self.losses}-{self.ties} (Win%: {self.win_percentage():.3f})"


# Data Management


class StatsDataset:
    """Handles loading and processing of player statistics data."""
    
    def __init__(self, df: pd.DataFrame):
        self._df = df
        self._validate_dataframe()

    @classmethod
    def from_csv(cls, path: str) -> 'StatsDataset':
        """Create dataset from CSV file."""
        try:
            df = pd.read_csv(path)
            return cls(df)
        except FileNotFoundError:
            raise FileNotFoundError(f"Could not find stats file: {path}")
        except pd.errors.EmptyDataError:
            raise ValueError("The CSV file is empty")

    def _validate_dataframe(self) -> None:
        """Validate that the dataframe has required columns."""
        required_cols = ["player", "team", "position"]
        missing_cols = [col for col in required_cols if col not in self._df.columns]
        if missing_cols:
            raise ValueError(f"Missing required columns: {missing_cols}")

    def create_player_from_row(self, row: pd.Series) -> Player:
        """
        Factory method to create appropriate Player subclass based on position.
        Demonstrates polymorphism - returns different Player types.
        """
        name = clean_name(row.get("player", ""))
        team = row.get("team")
        pos = str(row.get("position", "")).upper()
        games = int(row.get("games_played", 0))

        # Create appropriate player type based on position
        if pos in {"QB", "RB", "WR", "TE"}:  # Offensive positions
            return OffensivePlayer(
                name, team, pos,
                passing_yards=int(row.get("passing_yards", 0)),
                rushing_yards=int(row.get("rushing_yards", 0)),
                receiving_yards=int(row.get("receiving_yards", 0)),
                touchdowns=int(row.get("touchdowns", 0)),
                games_played=games
            )
        elif pos in {"DL", "LB", "CB", "S", "DE", "DT", "OLB", "MLB", "FS", "SS"}:  # Defensive positions
            return DefensivePlayer(
                name, team, pos,
                tackles=int(row.get("tackles", 0)),
                sacks=int(row.get("sacks", 0)),
                interceptions=int(row.get("interceptions", 0)),
                forced_fumbles=int(row.get("forced_fumbles", 0)),
                games_played=games
            )
        elif pos in {"K", "P", "KR", "PR"}:  # Special teams positions
            return SpecialTeamsPlayer(
                name, team, pos,
                field_goals_made=int(row.get("field_goals_made", 0)),
                field_goals_attempted=int(row.get("field_goals_attempted", 0)),
                punts_inside_20=int(row.get("punts_inside_20", 0)),
                return_tds=int(row.get("return_tds", 0)),
                games_played=games
            )
        else:
            # Generic player for unrecognized positions
            class GenericPlayer(Player):
                def efficiency_score(self) -> float:
                    return 0.0
                def get_primary_stats(self) -> Dict[str, Any]:
                    return {"position": self.position}
            
            return GenericPlayer(name, team, pos)

    def build_team_roster(self, team_abbr: str) -> Team:
        """Build a complete team roster from the dataset."""
        team_abbr = team_abbr.upper()
        if team_abbr not in VALID_TEAMS:
            raise ValueError(f"Invalid team abbreviation: {team_abbr}")
        
        # Filter data for specific team
        team_df = self._df[self._df["team"].str.upper() == team_abbr]
        team = Team(f"{team_abbr} Team", team_abbr)

        # Avoid duplicate players
        seen_players = set()
        for _, row in team_df.iterrows():
            player_name = clean_name(row.get("player"))
            if player_name in seen_players:
                continue
            
            seen_players.add(player_name)
            player = self.create_player_from_row(row)
            team.add_player(player)

        return team

    def get_all_teams(self) -> List[str]:
        """Get list of all teams in the dataset."""
        return sorted(self._df["team"].str.upper().unique())


# Analytics Engine


class AnalyticsEngine:
    """
    Provides statistical analysis and ranking functionality.
    Demonstrates polymorphism by working with Player base class.
    """
    
    @staticmethod
    def rank_players(players: List[Player], top_n: int = 5) -> pd.DataFrame:
        """
        Rank players by efficiency score.
        Polymorphic behavior - calls efficiency_score() method which behaves
        differently for each Player subclass.
        """
        if not players:
            return pd.DataFrame(columns=["rank", "player", "position", "team", "score"])
        
        player_data = []
        for player in players:
            player_data.append({
                "player": player.name,
                "position": player.position,
                "team": player.team,
                "score": round(player.efficiency_score(), 3),
                "games_played": player.games_played
            })
        
        # Sort by score and add rankings
        df = pd.DataFrame(player_data).sort_values("score", ascending=False).head(top_n)
        df.reset_index(drop=True, inplace=True)
        df.insert(0, "rank", range(1, len(df) + 1))
        
        return df

    @staticmethod
    def rank_teams(teams: List[Team]) -> pd.DataFrame:
        """Rank teams by average player efficiency."""
        if not teams:
            return pd.DataFrame(columns=["rank", "team", "avg_efficiency", "players"])
        
        team_data = []
        for team in teams:
            team_data.append({
                "team": team.abbreviation,
                "team_name": team.name,
                "avg_efficiency": round(team.average_efficiency(), 3),
                "players": len(team.roster),
                "top_player_score": round(max([p.efficiency_score() for p in team.roster], default=0), 3)
            })
        
        df = pd.DataFrame(team_data).sort_values("avg_efficiency", ascending=False)
        df.reset_index(drop=True, inplace=True)
        df.insert(0, "rank", range(1, len(df) + 1))
        
        return df

    @staticmethod
    def compare_positions(players: List[Player], position: str) -> pd.DataFrame:
        """Compare players at the same position."""
        position_players = [p for p in players if p.position == position.upper()]
        return AnalyticsEngine.rank_players(position_players, len(position_players))

    @staticmethod
    def team_position_analysis(team: Team) -> Dict[str, Any]:
        """Analyze team composition by position."""
        analysis = {}
        
        for pos in ["QB", "RB", "WR", "TE", "DL", "LB", "CB", "S", "K", "P"]:
            pos_players = team.get_players_by_position(pos)
            if pos_players:
                avg_efficiency = sum(p.efficiency_score() for p in pos_players) / len(pos_players)
                analysis[pos] = {
                    "count": len(pos_players),
                    "avg_efficiency": round(avg_efficiency, 3),
                    "best_player": max(pos_players, key=lambda p: p.efficiency_score()).name
                }
        
        return analysis

# Demo and Testing

def create_sample_data() -> pd.DataFrame:
    """Create sample NFL player data for demonstration."""
    sample_data = {
        "player": [
            "Josh Allen", "Stefon Diggs", "Jordan Poyer", "Matt Milano",
            "Tyler Bass", "Matt Haack", "Aaron Donald", "Cooper Kupp",
            "Jalen Ramsey", "Matthew Stafford"
        ],
        "team": [
            "BUF", "BUF", "BUF", "BUF", "BUF", "BUF", 
            "LAR", "LAR", "LAR", "LAR"
        ],
        "position": [
            "QB", "WR", "S", "LB", "K", "P", 
            "DL", "WR", "CB", "QB"
        ],
        "games_played": [17, 16, 15, 14, 17, 17, 16, 15, 16, 17],
        "passing_yards": [4306, 0, 0, 0, 0, 0, 0, 0, 0, 4886],
        "rushing_yards": [524, 3, 0, 0, 0, 0, 0, 8, 0, 43],
        "receiving_yards": [0, 1429, 0, 0, 0, 0, 0, 1947, 0, 0],
        "touchdowns": [42, 11, 1, 0, 0, 0, 0, 8, 0, 41],
        "tackles": [0, 12, 93, 92, 0, 0, 84, 4, 77, 0],
        "sacks": [0, 0, 1, 3, 0, 0, 20.5, 0, 0, 0],
        "interceptions": [0, 0, 5, 1, 0, 0, 0, 0, 4, 0],
        "forced_fumbles": [0, 0, 2, 1, 0, 0, 4, 0, 1, 0],
        "field_goals_made": [0, 0, 0, 0, 28, 0, 0, 0, 0, 0],
        "field_goals_attempted": [0, 0, 0, 0, 32, 0, 0, 0, 0, 0],
        "punts_inside_20": [0, 0, 0, 0, 0, 24, 0, 0, 0, 0],
        "return_tds": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    }
    
    return pd.DataFrame(sample_data)


def main():
    """Demonstrate the NFL Analytics system functionality."""
    print(" NFL Analytics System - Project 3 Demo")
    print("=" * 50)
    
    # Create sample dataset
    df = create_sample_data()
    stats_dataset = StatsDataset(df)
    
    # Build team rosters
    print("\n Building Team Rosters...")
    bills = stats_dataset.build_team_roster("BUF")
    rams = stats_dataset.build_team_roster("LAR")
    
    print(f"Buffalo Bills: {bills}")
    print(f"Los Angeles Rams: {rams}")
    
    # Demonstrate polymorphism - different efficiency calculations
    print("\n Player Efficiency Scores (Polymorphic Behavior):")
    for player in bills.roster[:3]:  # Show first 3 players
        stats = player.get_primary_stats()
        print(f"{player.name} ({player.position}): {player.efficiency_score():.2f}")
        print(f"   Primary stats: {stats}")
    
    # Team rankings
    print("\n Team Rankings:")
    team_rankings = AnalyticsEngine.rank_teams([bills, rams])
    print(team_rankings.to_string(index=False))
    
    # Player rankings across teams
    print("\n Top Players Overall:")
    all_players = bills.roster + rams.roster
    player_rankings = AnalyticsEngine.rank_players(all_players, top_n=8)
    print(player_rankings.to_string(index=False))
    
    # Position-specific analysis
    print("\n Wide Receiver Comparison:")
    wr_comparison = AnalyticsEngine.compare_positions(all_players, "WR")
    print(wr_comparison.to_string(index=False))
    
    # Team composition analysis
    print("\n Buffalo Bills Position Analysis:")
    bills_analysis = AnalyticsEngine.team_position_analysis(bills)
    for pos, data in bills_analysis.items():
        print(f"{pos}: {data['count']} players, avg efficiency: {data['avg_efficiency']}")
    
    # Demonstrate composition
    print("\n Team Season Stats (Composition Example):")
    bills.season_stats.add_game_result(31, 10)
    bills.season_stats.add_game_result(28, 25)
    bills.season_stats.add_game_result(17, 20)
    print(f"Bills {bills.season_stats}")
    print(f"Point Differential: {bills.season_stats.point_differential()}")


if __name__ == "__main__":
    main()
