# -*- coding: utf-8 -*-
"""test_nfl_analytics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WzwYc2ynHihrCn1XrAhWz5V5Bx7jTlAX
"""

"""
Test Suite for NFL Analytics System - Project 3
INST326 Advanced OOP with Inheritance & Polymorphism

This test suite covers inheritance, polymorphism, abstract classes, and composition.
"""

import unittest
import pandas as pd
from nfl_analytics_improved_project3 import (
    Player, OffensivePlayer, DefensivePlayer, SpecialTeamsPlayer,
    Team, SeasonStats, StatsDataset, AnalyticsEngine,
    VALID_TEAMS, clean_name
)


class TestInheritanceHierarchy(unittest.TestCase):
    """Test inheritance relationships and method overriding."""

    def setUp(self):
        """Set up test players for inheritance testing."""
        self.qb = OffensivePlayer("Test QB", "BUF", "QB",
                                passing_yards=3000, touchdowns=25, games_played=16)
        self.linebacker = DefensivePlayer("Test LB", "BUF", "LB",
                                        tackles=80, sacks=5, games_played=16)
        self.kicker = SpecialTeamsPlayer("Test K", "BUF", "K",
                                       field_goals_made=25, field_goals_attempted=30, games_played=16)

    def test_player_inheritance(self):
        """Test that all player types inherit from Player base class."""
        self.assertIsInstance(self.qb, Player)
        self.assertIsInstance(self.linebacker, Player)
        self.assertIsInstance(self.kicker, Player)

        # Test that they're also instances of their specific types
        self.assertIsInstance(self.qb, OffensivePlayer)
        self.assertIsInstance(self.linebacker, DefensivePlayer)
        self.assertIsInstance(self.kicker, SpecialTeamsPlayer)

    def test_super_calls_in_constructors(self):
        """Test that subclasses properly call parent constructors."""
        # All players should have name, team, position from parent class
        self.assertEqual(self.qb.name, "Test QB")
        self.assertEqual(self.qb.team, "BUF")
        self.assertEqual(self.qb.position, "QB")

        self.assertEqual(self.linebacker.name, "Test LB")
        self.assertEqual(self.linebacker.team, "BUF")

        self.assertEqual(self.kicker.name, "Test K")
        self.assertEqual(self.kicker.team, "BUF")

    def test_method_overriding(self):
        """Test that subclasses properly override parent methods."""
        # Each player type should have different string representations
        qb_str = str(self.qb)
        lb_str = str(self.linebacker)
        k_str = str(self.kicker)

        self.assertIn("QB", qb_str)
        self.assertIn("LB", lb_str)
        self.assertIn("K", k_str)

        # Test that summary_row works for all types (inherited method)
        qb_summary = self.qb.summary_row()
        self.assertIn("name", qb_summary)
        self.assertIn("efficiency_score", qb_summary)


class TestAbstractBaseClass(unittest.TestCase):
    """Test abstract base class enforcement."""

    def test_cannot_instantiate_abstract_player(self):
        """Test that you cannot directly instantiate the abstract Player class."""
        with self.assertRaises(TypeError):
            Player("Test", "BUF", "XX")

    def test_abstract_method_enforcement(self):
        """Test that abstract methods must be implemented."""
        # Try to create a player class that doesn't implement abstract methods
        with self.assertRaises(TypeError):
            class IncompletePlayer(Player):
                pass
            IncompletePlayer("Test", "BUF", "XX")

    def test_abstract_methods_implemented(self):
        """Test that all concrete classes implement required abstract methods."""
        qb = OffensivePlayer("Test QB", "BUF", "QB", games_played=1)
        lb = DefensivePlayer("Test LB", "BUF", "LB", games_played=1)
        k = SpecialTeamsPlayer("Test K", "BUF", "K", games_played=1)

        # All should be able to call abstract methods
        self.assertIsInstance(qb.efficiency_score(), (int, float))
        self.assertIsInstance(lb.efficiency_score(), (int, float))
        self.assertIsInstance(k.efficiency_score(), (int, float))

        self.assertIsInstance(qb.get_primary_stats(), dict)
        self.assertIsInstance(lb.get_primary_stats(), dict)
        self.assertIsInstance(k.get_primary_stats(), dict)


class TestPolymorphism(unittest.TestCase):
    """Test polymorphic behavior across player types."""

    def setUp(self):
        """Set up players with similar performance but different types."""
        self.players = [
            OffensivePlayer("QB1", "BUF", "QB", passing_yards=4000, touchdowns=30, games_played=16),
            DefensivePlayer("LB1", "BUF", "LB", tackles=100, sacks=10, interceptions=2, games_played=16),
            SpecialTeamsPlayer("K1", "BUF", "K", field_goals_made=30, field_goals_attempted=33, games_played=16)
        ]

    def test_polymorphic_efficiency_calculation(self):
        """Test that efficiency_score() behaves differently for each player type."""
        scores = []
        for player in self.players:
            # This is polymorphism - same method call, different behavior
            score = player.efficiency_score()
            scores.append(score)
            self.assertIsInstance(score, (int, float))
            self.assertGreater(score, 0)

        # Verify scores are calculated differently (not all the same)
        self.assertEqual(len(set(scores)), len(scores))  # All different values

    def test_polymorphic_stats_method(self):
        """Test that get_primary_stats() returns different data for each type."""
        stat_keys = []
        for player in self.players:
            stats = player.get_primary_stats()
            self.assertIsInstance(stats, dict)
            stat_keys.append(set(stats.keys()))

        # Each player type should have different primary stats
        qb_keys, lb_keys, k_keys = stat_keys
        self.assertNotEqual(qb_keys, lb_keys)
        self.assertNotEqual(lb_keys, k_keys)
        self.assertNotEqual(qb_keys, k_keys)

    def test_uniform_interface(self):
        """Test that polymorphism allows uniform treatment of different types."""
        # Analytics engine should work with all player types uniformly
        rankings = AnalyticsEngine.rank_players(self.players)

        self.assertEqual(len(rankings), 3)
        self.assertIn("rank", rankings.columns)
        self.assertIn("score", rankings.columns)

        # All players should appear in rankings regardless of type
        player_names = set(rankings["player"].tolist())
        expected_names = {"QB1", "LB1", "K1"}
        self.assertEqual(player_names, expected_names)


class TestComposition(unittest.TestCase):
    """Test composition relationships (has-a relationships)."""

    def setUp(self):
        """Set up team with players and season stats."""
        self.team = Team("Test Team", "BUF")
        self.players = [
            OffensivePlayer("QB1", "BUF", "QB", games_played=16),
            DefensivePlayer("LB1", "BUF", "LB", games_played=16),
            SpecialTeamsPlayer("K1", "BUF", "K", games_played=16)
        ]

    def test_team_has_players(self):
        """Test that Team contains Player objects (composition)."""
        # Initially empty
        self.assertEqual(len(self.team.roster), 0)

        # Add players
        for player in self.players:
            self.team.add_player(player)

        # Team now contains players
        self.assertEqual(len(self.team.roster), 3)
        self.assertIn(self.players[0], self.team.roster)

        # Players should have team reference updated
        for player in self.players:
            self.assertEqual(player.team, "BUF")

    def test_team_has_season_stats(self):
        """Test that Team contains SeasonStats object (composition)."""
        # Team should have season stats
        self.assertIsInstance(self.team.season_stats, SeasonStats)

        # Should be able to update season stats
        self.team.season_stats.add_game_result(21, 14)
        self.assertEqual(self.team.season_stats.wins, 1)
        self.assertEqual(self.team.season_stats.losses, 0)

    def test_composition_vs_inheritance(self):
        """Test that composition is used instead of inheritance where appropriate."""
        # Team HAS players (composition), Team is not a Player (inheritance)
        self.assertIsInstance(self.team.roster, list)
        self.assertFalse(isinstance(self.team, Player))

        # SeasonStats HAS game data, it's not a type of Team
        stats = self.team.season_stats
        self.assertFalse(isinstance(stats, Team))
        self.assertIsInstance(stats.wins, int)

    def test_team_player_management(self):
        """Test team operations on composed player objects."""
        # Add players
        for player in self.players:
            self.team.add_player(player)

        # Test position filtering
        qbs = self.team.get_players_by_position("QB")
        self.assertEqual(len(qbs), 1)
        self.assertEqual(qbs[0].position, "QB")

        # Test team summary
        summary = self.team.get_team_summary()
        self.assertEqual(summary["total_players"], 3)
        self.assertIn("average_efficiency", summary)

        # Test player removal
        removed = self.team.remove_player("QB1")
        self.assertTrue(removed)
        self.assertEqual(len(self.team.roster), 2)


class TestStatsDataset(unittest.TestCase):
    """Test data loading and player creation."""

    def setUp(self):
        """Set up sample data for testing."""
        self.sample_data = pd.DataFrame({
            "player": ["Josh Allen", "Aaron Donald", "Tyler Bass"],
            "team": ["BUF", "LAR", "BUF"],
            "position": ["QB", "DL", "K"],
            "games_played": [16, 15, 17],
            "passing_yards": [4000, 0, 0],
            "touchdowns": [30, 0, 0],
            "rushing_yards": [500, 0, 0],
            "receiving_yards": [0, 0, 0],
            "tackles": [0, 80, 0],
            "sacks": [0, 15, 0],
            "interceptions": [0, 0, 0],
            "field_goals_made": [0, 0, 25],
            "field_goals_attempted": [0, 0, 30]
        })
        self.dataset = StatsDataset(self.sample_data)

    def test_player_factory_method(self):
        """Test that create_player_from_row creates correct player types."""
        # Test QB creation
        qb_row = self.sample_data.iloc[0]
        qb = self.dataset.create_player_from_row(qb_row)
        self.assertIsInstance(qb, OffensivePlayer)
        self.assertEqual(qb.name, "Josh Allen")
        self.assertEqual(qb.passing_yards, 4000)

        # Test DL creation
        dl_row = self.sample_data.iloc[1]
        dl = self.dataset.create_player_from_row(dl_row)
        self.assertIsInstance(dl, DefensivePlayer)
        self.assertEqual(dl.name, "Aaron Donald")
        self.assertEqual(dl.sacks, 15)

        # Test K creation
        k_row = self.sample_data.iloc[2]
        k = self.dataset.create_player_from_row(k_row)
        self.assertIsInstance(k, SpecialTeamsPlayer)
        self.assertEqual(k.name, "Tyler Bass")
        self.assertEqual(k.field_goals_made, 25)

    def test_team_building(self):
        """Test building team rosters from data."""
        bills = self.dataset.build_team_roster("BUF")

        self.assertIsInstance(bills, Team)
        self.assertEqual(bills.abbreviation, "BUF")
        self.assertEqual(len(bills.roster), 2)  # Josh Allen and Tyler Bass

        # Test invalid team
        with self.assertRaises(ValueError):
            self.dataset.build_team_roster("INVALID")

    def test_data_validation(self):
        """Test dataset validation."""
        # Test missing required columns
        bad_data = pd.DataFrame({"wrong_column": [1, 2, 3]})
        with self.assertRaises(ValueError):
            StatsDataset(bad_data)


class TestAnalyticsEngine(unittest.TestCase):
    """Test analytics and ranking functionality."""

    def setUp(self):
        """Set up players and teams for analytics testing."""
        self.players = [
            OffensivePlayer("High Scorer", "BUF", "QB", touchdowns=40, games_played=16),
            OffensivePlayer("Medium Scorer", "BUF", "RB", rushing_yards=1000, games_played=16),
            DefensivePlayer("Low Scorer", "BUF", "LB", tackles=50, games_played=16)
        ]

        self.team1 = Team("Team 1", "BUF")
        self.team2 = Team("Team 2", "LAR")

        for player in self.players:
            self.team1.add_player(player)

    def test_player_rankings(self):
        """Test player ranking functionality."""
        rankings = AnalyticsEngine.rank_players(self.players)

        self.assertEqual(len(rankings), 3)
        self.assertIn("rank", rankings.columns)
        self.assertIn("score", rankings.columns)

        # Should be sorted by score descending
        scores = rankings["score"].tolist()
        self.assertEqual(scores, sorted(scores, reverse=True))

        # Top player should be the high scorer
        self.assertEqual(rankings.iloc[0]["player"], "High Scorer")

    def test_team_rankings(self):
        """Test team ranking functionality."""
        rankings = AnalyticsEngine.rank_teams([self.team1, self.team2])

        self.assertEqual(len(rankings), 2)
        self.assertIn("rank", rankings.columns)
        self.assertIn("avg_efficiency", rankings.columns)

    def test_position_comparison(self):
        """Test position-specific player comparison."""
        # Add another QB for comparison
        self.players.append(OffensivePlayer("Another QB", "LAR", "QB",
                                          touchdowns=20, games_played=16))

        qb_rankings = AnalyticsEngine.compare_positions(self.players, "QB")

        self.assertEqual(len(qb_rankings), 2)  # Should only include QBs
        for _, row in qb_rankings.iterrows():
            self.assertEqual(row["position"], "QB")


class TestUtilityFunctions(unittest.TestCase):
    """Test utility functions and validation."""

    def test_clean_name(self):
        """Test name cleaning functionality."""
        self.assertEqual(clean_name("  Josh Allen  "), "Josh Allen")
        self.assertEqual(clean_name("Test"), "Test")
        self.assertEqual(clean_name(123), "123")  # Should convert to string

    def test_valid_teams(self):
        """Test team abbreviation validation."""
        self.assertIn("BUF", VALID_TEAMS)
        self.assertIn("LAR", VALID_TEAMS)
        self.assertNotIn("INVALID", VALID_TEAMS)

        # Test team creation with valid/invalid abbreviations
        Team("Buffalo Bills", "BUF")  # Should work

        with self.assertRaises(ValueError):
            Team("Invalid Team", "INVALID")


class TestSeasonStats(unittest.TestCase):
    """Test season statistics tracking."""

    def setUp(self):
        """Set up season stats for testing."""
        self.stats = SeasonStats()

    def test_game_result_tracking(self):
        """Test recording game results."""
        self.stats.add_game_result(21, 14)  # Win
        self.assertEqual(self.stats.wins, 1)
        self.assertEqual(self.stats.losses, 0)

        self.stats.add_game_result(10, 17)  # Loss
        self.assertEqual(self.stats.wins, 1)
        self.assertEqual(self.stats.losses, 1)

        self.stats.add_game_result(14, 14)  # Tie
        self.assertEqual(self.stats.ties, 1)

    def test_win_percentage_calculation(self):
        """Test win percentage calculation."""
        # No games played
        self.assertEqual(self.stats.win_percentage(), 0.0)

        # Add some games
        self.stats.add_game_result(21, 14)  # Win
        self.stats.add_game_result(10, 17)  # Loss

        # Should be 50%
        self.assertEqual(self.stats.win_percentage(), 0.5)

    def test_point_differential(self):
        """Test point differential calculation."""
        self.stats.add_game_result(21, 14)  # +7
        self.stats.add_game_result(10, 17)  # -7

        self.assertEqual(self.stats.point_differential(), 0)


if __name__ == "__main__":
    # Create test suite
    test_suite = unittest.TestSuite()

    # Add all test classes
    test_classes = [
        TestInheritanceHierarchy,
        TestAbstractBaseClass,
        TestPolymorphism,
        TestComposition,
        TestStatsDataset,
        TestAnalyticsEngine,
        TestUtilityFunctions,
        TestSeasonStats
    ]

    for test_class in test_classes:
        tests = unittest.TestLoader().loadTestsFromTestCase(test_class)
        test_suite.addTests(tests)

    # Run tests
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(test_suite)

    # Print summary
    print(f"\n{'='*50}")
    print(f"TESTING SUMMARY")
    print(f"{'='*50}")
    print(f"Tests run: {result.testsRun}")
    print(f"Failures: {len(result.failures)}")
    print(f"Errors: {len(result.errors)}")

    if result.wasSuccessful():
        print("✅ ALL TESTS PASSED!")
    else:
        print("❌ Some tests failed. Check output above.")