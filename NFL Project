"""
NFL Player Stats Function Library

This file organizes all our functions for NFL player analytics.
It’s divided into clear sections so each part of the project stays organized.

Team: Gridiron Data Systems (David, Dash, Andrew)
Course: INST326 - Object-Oriented Programming for Information Science
"""
# ===========================
# 1. Validation / Simple Helpers
# ===========================
# Small helper functions for cleaning and checking data:
# - Validate team names (like "KC" or "BAL")
# - Validate player positions (like "QB" or "RB")
# - Clean and normalize player names
# - Safe math functions (avoid divide-by-zero errors)

# ===========================
# 1) Validation / Simple Helpers (API version)
# ===========================

VALID_TEAMS = {
    "ARI", "ATL", "BAL", "BUF", "CAR", "CHI", "CIN", "CLE",
    "DAL", "DEN", "DET", "GB", "HOU", "IND", "JAX", "KC",
    "LV", "LAC", "LAR", "MIA", "MIN", "NE", "NO", "NYG",
    "NYJ", "PHI", "PIT", "SEA", "SF", "TB", "TEN", "WAS"
}

VALID_POSITIONS = {
    "QB", "RB", "WR", "TE", "FB", "OL", "DL", "LB", "CB", "S", "K", "P"
}

def clean_name(name: str) -> str:
    """Fix player name formatting (strip spaces, title case)."""
    if not isinstance(name, str):
        return ""
    return " ".join(name.strip().split()).title()

def safe_divide(a: float, b: float, default: float = 0.0) -> float:
    """Divide safely; return default if b == 0."""
    try:
        return a / b if b != 0 else default
    except Exception:
        return default

def validate_team(team: str) -> bool:
    """Return True if the team is a valid NFL abbreviation."""
    return isinstance(team, str) and team.upper() in VALID_TEAMS

def validate_position(pos: str) -> bool:
    """Return True if the position is valid."""
    return isinstance(pos, str) and pos.upper() in VALID_POSITIONS



# ==========================================
# 2. Data Loading, Merging, and Canonicalization
# ==========================================
# Functions that handle loading and preparing data:
# - Load CSV or API data
# - Merge different tables (like weekly stats + player info)
# - Rename and organize columns for consistency
from __future__ import annotations
from typing import Dict, List, Optional
import pandas as pd
import requests


def load_csv_data(path: str, dtype: Optional[Dict] = None) -> pd.DataFrame:
    """Load a CSV into a DataFrame."""
    df = pd.read_csv(path, dtype=dtype)
    if df.empty:
        raise ValueError(f"CSV is empty: {path}")
    return df


def fetch_api_data(url: str, params: Optional[Dict] = None, headers: Optional[Dict] = None, timeout: int = 20) -> dict | list:
    """Fetch JSON data from an API."""
    try:
        resp = requests.get(url, params=params, headers=headers, timeout=timeout)
        if resp.status_code != 200:
            raise RuntimeError(f"HTTP {resp.status_code}: {resp.text[:150]}")
        return resp.json()
    except Exception as e:
        raise RuntimeError(f"API request failed: {e}")


def api_to_dataframe(data: dict | list, field_map: Optional[Dict[str, str]] = None, keep_extra: bool = False) -> pd.DataFrame:
    """Convert API JSON into a DataFrame and rename keys if needed."""
    if isinstance(data, dict):
        rows = data.get("data", [data])
    elif isinstance(data, list):
        rows = data
    else:
        raise TypeError("API data must be dict or list")
    
    df = pd.DataFrame(rows)
    if field_map:
        df = df.rename(columns={k: v for k, v in field_map.items() if k in df.columns})
        if not keep_extra:
            df = df[[v for v in field_map.values() if v in df.columns]]
    return df


def merge_datasets(left: pd.DataFrame, right: pd.DataFrame, on: str | List[str], how: str = "left", dedupe_keys: Optional[List[str]] = None) -> pd.DataFrame:
    """Merge two DataFrames."""
    if dedupe_keys:
        right = right.drop_duplicates(subset=dedupe_keys)
    return left.merge(right, on=on, how=how)

# =========================
# 3. Calculations and Analysis
# =========================
# Main football analytics section:
# - Calculate QB ratings and player efficiency
# - Create leaderboards (top players by stat)
# - Compare players and analyze performance trends
# - Predict or estimate future stats 

from typing import List, Dict, Optional
import pandas as pd

def qb_rating(att: int, comp: int, yds: int, td: int, ints: int) -> float:
    """NFL passer rating (0.0–158.3). Short + safe."""
    if att <= 0:
        return 0.0

    # tiny helper so the formula parts stay in [0, 2.375]
    def clip(x: float) -> float:
        return 0.0 if x < 0 else (2.375 if x > 2.375 else x)

    a = clip(((comp / att) - 0.3) * 5)
    b = clip(((yds / att) - 3) * 0.25)
    c = clip((td / att) * 20)
    d = clip(2.375 - ((ints / att) * 25))

    return round(((a + b + c + d) / 6) * 100, 1)

def efficiency(yards: float, plays: float, touchdowns: float = 0) -> Dict[str, float]:
    """Super simple efficiency: yards/play and TD rate."""
    ypp = yards / plays if plays else 0.0
    td_rate = touchdowns / plays if plays else 0.0
    return {"ypp": round(ypp, 3), "td_rate": round(td_rate, 4)}

def create_leaderboard(
    df: pd.DataFrame,
    stat: str,
    position: Optional[str] = None,
    season: Optional[int] = None,
    top_n: int = 10,
) -> pd.DataFrame:
    """Top-N players by a stat (sums rows first)."""
    if not isinstance(df, pd.DataFrame) or "player" not in df.columns or stat not in df.columns:
        return pd.DataFrame()

    data = df.copy()

    # quick filters if cols exist
    if season is not None and "season" in data.columns:
        data = data[data["season"] == season]
    if position is not None and "position" in data.columns:
        data = data[data["position"].str.upper() == position.upper()]

    # sum per player so multiple games roll up
    out = (
        data.groupby("player", dropna=False)[stat]
        .sum(numeric_only=True)
        .reset_index()
        .sort_values(stat, ascending=False)
        .head(top_n)
    )
    out.insert(0, "rank", range(1, len(out) + 1))
    return out[["rank", "player", stat]]


def compare_players(
    df: pd.DataFrame,
    players: List[str],
    stats: List[str],
) -> Dict[str, Dict[str, float]]:
    """Compare players across a few stats. Returns a simple dict."""
    if not isinstance(df, pd.DataFrame) or "player" not in df.columns:
        return {}

    # light name normalizer so '  tua TAGOVAILOA ' matches fine
    def _norm(s: str) -> str:
        return " ".join(str(s).strip().split()).title()

    wanted = {_norm(p) for p in players}
    data = df.copy()
    data["player_norm"] = data["player"].map(_norm)

    # only keep requested players; fill missing stats with 0
    keep_cols = ["player_norm"] + [s for s in stats if s in data.columns]
    sub = data[keep_cols].copy()
    agg = sub[sub["player_norm"].isin(wanted)].groupby("player_norm")[stats].sum(numeric_only=True)

    result: Dict[str, Dict[str, float]] = {p: {s: 0.0 for s in stats} for p in wanted}
    for name, row in agg.iterrows():
        result[name] = {s: float(row.get(s, 0.0)) for s in stats}
    return result


def forecast_mean_last_n(
    df: pd.DataFrame,
    player: str,
    stat: str,
    n: int = 5,
) -> Dict[str, float]:
    """Baseline forecast = avg of last N games for that stat."""
    if not isinstance(df, pd.DataFrame) or "player" not in df.columns or stat not in df.columns:
        return {"player": player, "stat": stat, "n": 0.0, "forecast": 0.0}

    def _norm(s: str) -> str:
        return " ".join(str(s).strip().split()).title()

    p = _norm(player)
    data = df.copy()
    data["player_norm"] = data["player"].map(_norm)

    # sort per player by week if we have it; else by date if we have that
    if "week" in data.columns:
        data = data.sort_values(["player_norm", "week"])
    elif "game_date" in data.columns:
        data = data.sort_values(["player_norm", "game_date"])

    recent = data[data["player_norm"] == p].dropna(subset=[stat]).tail(max(1, int(n)))
    vals = recent[stat].tolist()
    avg = (sum(vals) / len(vals)) if len(vals) else 0.0

    return {"player": p, "stat": stat, "n": float(len(vals)), "forecast": round(avg, 2)}



# ========================
# 4. Visualization and Export
# ========================
# Functions to show and share results:
# - Plot leaderboards or player comparisons using bar charts
# - Export results to CSV files for reporting
from typing import Optional
import os
import pandas as pd
import matplotlib.pyplot as plt

def plot_leaderboard(
    df: pd.DataFrame,
    stat: str,
    position: Optional[str] = None,
    season: Optional[int] = None,
    top_n: int = 10,
    save_path: Optional[str] = None,
    show: bool = True,
) -> pd.DataFrame:
    """Bar chart for top-N by a stat. Returns the table used for the plot."""
    if not isinstance(df, pd.DataFrame) or "player" not in df.columns or stat not in df.columns:
        print("plot_leaderboard: bad input")
        return pd.DataFrame()

    # reuse our analysis helper
    lb = create_leaderboard(df, stat=stat, position=position, season=season, top_n=top_n)
    if lb.empty:
        print("plot_leaderboard: nothing to plot")
        return lb

    names = lb["player"].tolist()
    values = lb[stat].tolist()

    plt.figure(figsize=(9, 5))
    # horizontal so long names fit
    plt.barh(range(len(names))[::-1], values[::-1])
    plt.yticks(range(len(names))[::-1], names[::-1])
    title_bits = [f"Top {len(names)}", stat.replace("_", " ").title()]
    if position: title_bits.append(f"({position.upper()})")
    if season:   title_bits.append(str(season))
    plt.title(" ".join(title_bits))
    plt.xlabel(stat.replace("_", " ").title())
    plt.tight_layout()

    if save_path:
        os.makedirs(os.path.dirname(save_path) or ".", exist_ok=True)
        plt.savefig(save_path, dpi=150, bbox_inches="tight")
        print(f"saved: {save_path}")
    if show:
        plt.show()
    else:
        plt.close()

    return lb

def plot_player_trend(
    df: pd.DataFrame,
    player: str,
    stat: str,
    save_path: Optional[str] = None,
    show: bool = True,
) -> pd.DataFrame:
    """Line plot of a player's stat over time (by week if available)."""
    if not isinstance(df, pd.DataFrame) or "player" not in df.columns or stat not in df.columns:
        print("plot_player_trend: bad input")
        return pd.DataFrame()

    norm = lambda s: " ".join(str(s).strip().split()).title()
    p = norm(player)
    data = df.copy()
    data["player_norm"] = data["player"].map(norm)
    sub = data[data["player_norm"] == p].dropna(subset=[stat]).copy()
    if sub.empty:
        print("plot_player_trend: player not found or no data")
        return sub

    # pick an x-axis
    if "week" in sub.columns:
        sub = sub.sort_values("week")
        x = sub["week"]
        x_label = "Week"
    elif "game_date" in sub.columns:
        sub = sub.sort_values("game_date")
        x = sub["game_date"]
        x_label = "Game Date"
    else:
        sub = sub.reset_index(drop=True)
        x = sub.index + 1
        x_label = "Game #"

    y = sub[stat]

    plt.figure(figsize=(9, 4))
    plt.plot(x, y, marker="o")
    plt.title(f"{p} — {stat.replace('_', ' ').title()}")
    plt.xlabel(x_label)
    plt.ylabel(stat.replace("_", " ").title())
    plt.tight_layout()

    if save_path:
        os.makedirs(os.path.dirname(save_path) or ".", exist_ok=True)
        plt.savefig(save_path, dpi=150, bbox_inches="tight")
        print(f"saved: {save_path}")
    if show:
        plt.show()
    else:
        plt.close()

    return sub[[x_label] if isinstance(x_label, str) else "index"].assign(**{stat: y.values})

def export_to_csv(df: pd.DataFrame, path: str) -> None:
    """Save a DataFrame to CSV."""
    if not isinstance(df, pd.DataFrame) or df.empty:
        print("export_to_csv: nothing to save")
        return
    os.makedirs(os.path.dirname(path) or ".", exist_ok=True)
    df.to_csv(path, index=False)
    print(f"saved: {path}")

def export_to_json(df: pd.DataFrame, path: str, orient: str = "records") -> None:
    """Save a DataFrame to JSON."""
    if not isinstance(df, pd.DataFrame) or df.empty:
        print("export_to_json: nothing to save")
        return
    os.makedirs(os.path.dirname(path) or ".", exist_ok=True)
    df.to_json(path, orient=orient)
    print(f"saved: {path}")

# ===========================
from__future__ import annotations
from typing import Dict, List, Optional, Any
import pandas as pd
from datetime import datetime
# ===========================

# ===========================
# Class 1: Player
# ===========================

"""This will represent an NFL player with their basic information

This class will encapsulate player identity, position, team affiliation, and provides methods for managing and
analyzing player statistics.

Attributes: 
    player_id (str): Unique identifier for the player
    name (str): Player's full name (cleaned and formatted)
    position (str): Playing positions (QB, RB, WR, etc.)
    team (str): Current Team abbreviation

Example: 
    player = Player("P001", "Patrick Mahomes", "QB", "KC")
    print(player)
    Patrick Mahomes (QB) - KC
    player.is_quaterback()
    True
"""
VALID_POSITIONS = {
        "QB", "RB", "WR", "TE", "FB", "OL", "DL", "LB", "CB", "S", "K", "P"
    }
    
    VALID_TEAMS = {
        "ARI", "ATL", "BAL", "BUF", "CAR", "CHI", "CIN", "CLE",
        "DAL", "DEN", "DET", "GB", "HOU", "IND", "JAX", "KC",
        "LV", "LAC", "LAR", "MIA", "MIN", "NE", "NO", "NYG",
        "NYJ", "PHI", "PIT", "SEA", "SF", "TB", "TEN", "WAS"
    }

def __init__(self, player_id: str, name: str, position: str, team: str):
    """Initialize a Player Instance.

    Args: player_id (str): Unique identifier for the player
    name (str): Player's full name
    position (str): Playing position (must be a valid NFL position)
    team (str): Team abbreviation (must be a valid NFL Team)

    Raises: 
        ValueError: If any parameter is invalid or empty
"""
if not isinstance(player_id, str) or not player_id.strip():
    raise ValueError("Player ID cannot be empty")

if not isinstance(name, str) or not name.strip():
    raise ValueError("Player name cannot be empty")

if not isinstance(position, str) or position.upper() not in self.VALID_POSITIONS:
    raise ValueError(f"Invalid position: {position}. Must be on of {self.VALID_POSITIONS}")

if not isinstance(team, str) or team.upper() not in self.VALID_TEAMS:
    raise ValueError(f"Invalid: {team}. Must be one of {self.VALID_TEAMS}")

self._player_id = player_id.strip()
self._name = self._clean_name(name)
self._position = position.upper()
self._team = team.upper()
self._stats_history: List[GameStats] = []

@staticmethod
def _clean_name(name: str) ->: str:
    """Clean and format player name (integration with Project 1 Function)."""
    return " ".join(name.strip().split()).title()

@property
def player_id(self) -> str:
    """str: Get the player ID (read-only)."""
    return self._player_id

@property
def name(self) -> str:
    """str: Get the player's name."""
    return self._name

@property
def position(self) -> str:
    """str: Get the player's position."""
    return self._position

@property
def team(self) -> str: 
    """str: Get the player's team."""
    return self._team

@team.setter
def team(self, new_team: str) -> None:
    """Set player's team (for trades/signings)."""
    if no isinstance(new_team, str) or new_team.upper() not in self.VALID_TEAMS:
        raise ValueError(f"Invalid team: {new_team}")
    self._team = new_team.upper()

def is_quarterback(self) -> bool:
    """Check if player is a quarterback."""
    return self._position == "QB"

def is_skill_position(self) -> bool:
    """Check if player is in a skill position (QB, RB, WR, TE)."""
    return self._position in {"QB", "RB", "WR", "TE"}

def add_game_stats(self, stats: GameStats) -> None:
    """Add game statistics to player's history.

    Args: 
        stats (GameStats): Game Statistics object to add

    Raises: 
        ValueError: If stats object is invalid

    if not isinstance(stats, GameStats):
        raise ValueError("Must provide a valid GameStats object")
    self._stats_history.append(stats)

def get_career_totals(self, stat_name: str) -> float:
    """Calculate career total for a specific statistics.

    Args: 
        stat_name (str): Name of the statistics (e.g. 'passing_yards', 'touchdowns')

    Returns:
        floatTotal value of the statistic across all games
    """

    total = 0.0
    for game in self._stats_history:
        total += game.get_stat(stat_name)
    return total

def __str__(self) -> str: 
    """Return user-friendly string representation."""
    return f"{self._name} ({self._position}) - {self._team}"

def __repr__(self) -> str: 
    """Return detailed string representation for debugging."""
    return f"Player(id = 'self._player_id}', name = '{self._name}', position = '{self._position}', team = '{self._team}')"

# ===========================
# Class 2: GameStats
# ===========================

# ===========================
# Class 3: Season
# ===========================

# ===========================
# Class 4: Team
# ===========================
